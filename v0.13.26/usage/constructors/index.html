<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constructors · ApproxFun.jl</title><meta name="title" content="Constructors · ApproxFun.jl"/><meta property="og:title" content="Constructors · ApproxFun.jl"/><meta property="twitter:title" content="Constructors · ApproxFun.jl"/><meta name="description" content="Documentation for ApproxFun.jl."/><meta property="og:description" content="Documentation for ApproxFun.jl."/><meta property="twitter:description" content="Documentation for ApproxFun.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ApproxFun.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ApproxFun.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../domains/">Domains</a></li><li><a class="tocitem" href="../spaces/">Spaces</a></li><li class="is-active"><a class="tocitem" href>Constructors</a><ul class="internal"><li><a class="tocitem" href="#Convenience-constructors"><span>Convenience constructors</span></a></li><li><a class="tocitem" href="#Specifying-coefficients-explicitly"><span>Specifying coefficients explicitly</span></a></li><li><a class="tocitem" href="#Using-ApproxFun-for-“manual”-interpolation"><span>Using ApproxFun for “manual” interpolation</span></a></li></ul></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../equations/">Linear Equations</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/ODE/">Solving ODEs</a></li><li><a class="tocitem" href="../../generated/system_of_eqn/">System of equations</a></li><li><a class="tocitem" href="../../generated/PDE/">Solving PDEs</a></li><li><a class="tocitem" href="../../generated/Sampling/">Sampling</a></li><li><a class="tocitem" href="../../generated/Periodic/">Periodic Domains</a></li><li><a class="tocitem" href="../../generated/Eigenvalue/">Eigenvalue problem</a></li><li><a class="tocitem" href="../../generated/NonlinearBVP/">Nonlinear Boundary Value Problem</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../internals/multivariate/">Multivariate functions</a></li><li><a class="tocitem" href="../../internals/blocks/">Blocks</a></li><li><a class="tocitem" href="../../internals/spaces/">Spaces</a></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Constructors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constructors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaApproximation/ApproxFun.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaApproximation/ApproxFun.jl/blob/master/docs/src/usage/constructors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h1><p><code>Fun</code>s in ApproxFun are instances of Julia types with one field to store coefficients and another to describe the function space. Similarly, each function space has one field describing its domain, or another function space. Let&#39;s explore:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Fun(identity,-1..1);

julia&gt; f = exp(x);

julia&gt; space(f) == Chebyshev(-1..1)
true</code></pre><p>In this example, <code>f</code> is a <code>Fun</code> that corresponds to a Chebyshev interpolant to <code>exp(x)</code>, and evaluating <code>f(x)</code> will generate a close approximation to <code>exp(x)</code>. In this case, the space is automatically inferred from the domain.</p><p><code>Fun</code>s may also incorporate singularities at the edges of the domain. In such cases, if the variable is in a polynomial space, the resulting space is a <a href="../spaces/#JacobiWeight"><code>JacobiWeight</code></a>, which factors out the singularity and interpolates the residual analytical component. Perhaps this is best illustrated through an example:</p><pre><code class="language-julia-repl hljs">julia&gt; g = f/sqrt(1-x^2);

julia&gt; space(g) == JacobiWeight(-0.5, -0.5, Chebyshev(-1..1))
true</code></pre><p>The function <code>g</code> in this case is expanded the basis <span>$(1-x^2)^{1/2}\;T_n(x)$</span>, where <span>$T_n(x)$</span> are Chebyshev polynomials. This is equivalent to expanding the function <code>f</code> in a Chebyshev basis.</p><p>The absolute value is another case where the space of the output is inferred from the operation:</p><pre><code class="language-julia-repl hljs">julia&gt; f = Fun(x-&gt;cospi(5x), -1..1);

julia&gt; g = abs(f);

julia&gt; space(g) isa ContinuousSpace # Piecewise continuous functions
true

julia&gt; domain(g) isa PiecewiseSegment # Segments interspersed by the roots of f
true</code></pre><p>We may check that the domain corresponds to segments separated by the roots of <code>f</code>, and the space is that of continuous functions over the piecewise domain:</p><pre><code class="language-julia-repl hljs">julia&gt; p = [-1; roots(f); 1];

julia&gt; segments = [Segment(x,y) for (x,y) in zip(p[1:end-1], p[2:end])];

julia&gt; components(domain(g)) == segments
true

julia&gt; space(g) == ContinuousSpace(PiecewiseSegment(reverse(segments)))
true</code></pre><h2 id="Convenience-constructors"><a class="docs-heading-anchor" href="#Convenience-constructors">Convenience constructors</a><a id="Convenience-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-constructors" title="Permalink"></a></h2><p>The default space is <code>Chebyshev</code>, which can represent non-periodic functions on intervals.  Each <code>Space</code> type has a default domain: for <code>Chebyshev</code> this is <code>-1..1</code>, for Fourier and Laurent this is <code>-π..π</code>.  Thus the following are equivalent:</p><pre><code class="language-julia hljs">Fun(exp,Chebyshev(Interval(-1,1)))
Fun(exp,Chebyshev(ChebyshevInterval()))
Fun(exp,Chebyshev(-1..1))
Fun(exp,Chebyshev())
Fun(exp,-1..1)
Fun(exp,ChebyshevInterval())
Fun(exp,Interval(-1,1))
Fun(exp)</code></pre><p>If a function is not specified, then it is taken to be <code>identity</code>.  Thus we have the following equivalent constructions:</p><pre><code class="language-julia hljs">x = Fun(identity, -1..1)
x = Fun(-1..1)
x = Fun(identity)
x = Fun()</code></pre><h2 id="Specifying-coefficients-explicitly"><a class="docs-heading-anchor" href="#Specifying-coefficients-explicitly">Specifying coefficients explicitly</a><a id="Specifying-coefficients-explicitly-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-coefficients-explicitly" title="Permalink"></a></h2><p>It is sometimes necessary to specify coefficients explicitly.  This is possible via specifying the space followed by a vector of coefficients:</p><pre><code class="language-julia-repl hljs">julia&gt; f = Fun(Taylor(), [1,2,3]);  # represents 1 + 2z + 3z^2

julia&gt; f(0.1) ≈ 1 + 2*0.1 + 3*0.1^2
true</code></pre><p>In higher dimensions, ApproxFun will sum products of the 1D basis functions. So if <span>$\mathop{T}_i(x)$</span> is the <span>$i$</span>th basis function, then a 2D function can be approximated as the following:</p><p class="math-container">\[\mathop{f}(x,y) = \sum_{i,j} c_{ij} \mathop{T}_i(x) \mathop{T}_j(y).\]</p><p>The products will be ordered lexicographically by the degree of the polynomial, i.e., in the order</p><p class="math-container">\[\mathop{T}_0(x) \mathop{T}_0(y),\ \mathop{T}_0(x) \mathop{T}_1(y),\ \mathop{T}_1(x) \mathop{T}_0(y),\ \mathop{T}_0(x) \mathop{T}_2(y),\ \mathop{T}_1(x) \mathop{T}_1(y),\ \mathop{T}_2(x) \mathop{T}_0(y),\ ….\]</p><p>For example, if we are in the two dimensional CosSpace space and we have coefficients <span>$\{c_1, c_2, c_3\}$</span>, then</p><p class="math-container">\[\mathop{f}(x, y) = c_1 \cos(0 x) \cos(0 y) + c_2 \cos(0 x) \cos(1 y) + c_3 \cos(1 x) \cos(0 y).\]</p><p>This is illustrated in the following code:</p><pre><code class="language-julia-repl hljs">julia&gt; f = Fun(CosSpace()^2, [1,2,3]);

julia&gt; f(1,2) ≈ 1cos(0*1)*cos(0*2) + 2cos(0*1)*cos(1*2) + 3cos(1*1)*cos(0*2)
true</code></pre><h2 id="Using-ApproxFun-for-“manual”-interpolation"><a class="docs-heading-anchor" href="#Using-ApproxFun-for-“manual”-interpolation">Using ApproxFun for “manual” interpolation</a><a id="Using-ApproxFun-for-“manual”-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Using-ApproxFun-for-“manual”-interpolation" title="Permalink"></a></h2><p>The ApproxFun package for Julia implements all of the necessary operations for Chebyshev interpolation and operations (like differentiation or integration) on Chebyshev interpolants.</p><p>Normally, you give it a function f and a domain d, and construct the Chebyshev interpolant by <code>fc = Fun(f, d)</code>. The ApproxFun package figures out the necessary number of Chebyshev points (i.e., the polynomial order) required to interpolate f to nearly machine precision, so that subsequent operations on fc can be viewed as &quot;exact&quot;.</p><p>However, in cases where the function to be interpolated is extremely expensive, and possibly even is evaluated by an external program, it is convenient to be able to decide on the desired Chebyshev order in advance, evaluate the function at those points &quot;manually&quot;, and then construct the Chebyshev interpolant. An example showing how to do this is given in the <a href="../../faq/">ApproxFun FAQ</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spaces/">« Spaces</a><a class="docs-footer-nextpage" href="../operators/">Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Saturday 16 March 2024 12:26">Saturday 16 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
