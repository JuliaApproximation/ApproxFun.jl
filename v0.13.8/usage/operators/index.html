<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operators · ApproxFun.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ApproxFun.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ApproxFun.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../domains/">Domains</a></li><li><a class="tocitem" href="../spaces/">Spaces</a></li><li><a class="tocitem" href="../constructors/">Constructors</a></li><li class="is-active"><a class="tocitem" href>Operators</a><ul class="internal"><li><a class="tocitem" href="#Calculus-operators"><span>Calculus operators</span></a></li><li><a class="tocitem" href="#Functionals"><span>Functionals</span></a></li><li><a class="tocitem" href="#Multiplication"><span>Multiplication</span></a></li><li><a class="tocitem" href="#Algebraic-manipulation-of-operators"><span>Algebraic manipulation of operators</span></a></li><li><a class="tocitem" href="#Operators-and-space-promotion"><span>Operators and space promotion</span></a></li><li><a class="tocitem" href="#Concatenating-operators"><span>Concatenating operators</span></a></li></ul></li><li><a class="tocitem" href="../equations/">Linear Equations</a></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaApproximation/ApproxFun.jl/blob/master/docs/src/usage/operators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h1><p>Linear operators between two spaces in ApproxFun are represented by subtypes of <code>Operator</code>.  Every operator has a <code>domainspace</code> and <code>rangespace</code>.  That is, if a <code>Fun</code> <code>f</code> has the space <code>domainspace(op)</code>, then<code>op*f</code> is a <code>Fun</code> with space <code>rangespace(op)</code>.</p><p>Note that the size of an operator is specified by the dimension of the domain and range space.  </p><h2 id="Calculus-operators"><a class="docs-heading-anchor" href="#Calculus-operators">Calculus operators</a><a id="Calculus-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Calculus-operators" title="Permalink"></a></h2><p>Differential and integral operators are perhaps the most useful type of operators in mathematics.  Consider the derivative operator on <code>CosSpace</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = Derivative(CosSpace())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteDerivative : CosSpace(【0.0,6.283185307179586❫) → SinSpace(【0.0,6.283185307179586❫) 0.0  -1.0    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    0.0  -2.0    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅     ⋅    0.0  -3.0    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅     ⋅     ⋅    0.0  -4.0    ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅    0.0  -5.0    ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅    0.0  -6.0    ⋅     ⋅     ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.0  -7.0    ⋅     ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.0  -8.0    ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.0  -9.0  ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.0  ⋱
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋱</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = Fun(θ-&gt;cos(cos(θ)), CosSpace());</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fp = D*f;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fp(0.1) ≈ f&#39;(0.1) ≈ sin(cos(0.1))*sin(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Here, we specified the domain space for the derivative operator, and it automatically determined the range space:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rangespace(D) == space(fp) == SinSpace()</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Operators can be identified with infinite-dimensional matrices, whose entries are given by the canonical bases in the domain and range space.  In this case, the relevant formula is</p><p class="math-container">\[\mathop{D} \cos{kθ} = -k \sin{kθ}.\]</p><p>That is, the <code>(k,k+1)</code>th entry is as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; k,j = 5,6;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ej = Fun(domainspace(D),[zeros(j-1);1]);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D[k,j] ≈ (D*ej).coefficients[k] ≈ -k</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The <code>Chebyshev</code> space has the property that its derivatives are given by ultraspherical spaces:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Derivative(Chebyshev())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteDerivative : Chebyshev() → Ultraspherical(1) ⋅  1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅   2.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅   3.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅   4.0   ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅   5.0   ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅   6.0   ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   7.0   ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   8.0   ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   9.0  ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋱
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋱</code></pre><h2 id="Functionals"><a class="docs-heading-anchor" href="#Functionals">Functionals</a><a id="Functionals-1"></a><a class="docs-heading-anchor-permalink" href="#Functionals" title="Permalink"></a></h2><p>A particularly useful class of operators are <em>functionals</em>, which map from functions to scalar numbers.  These are represented by operators of size <code>1 × ∞</code>: that is, infinite-dimensional analogues of row vectors.</p><p>As an example, the evaluation functional <code>f(0)</code> on <code>CosSpace</code> has the form:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = Evaluation(CosSpace(),0)</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteEvaluation : CosSpace(【0.0,6.283185307179586❫) → ConstantSpace(Point(0)) 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  ⋯</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B*f ≈ f(0)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>As can be seen from the output, <code>rangespace(B)</code> is a <code>ConstantSpace(Point(0))</code>, a one-dimensional space used to represent scalars whose domain is a single point, <code>0</code>.</p><p>Closely related to functionals are operators with finite-dimensional range.  For example, the <code>Dirichlet</code> operator represents the restriction of a space to its boundary.  In the case, of <code>Chebyshev()</code>, this amounts to evaluation at the endpoints <code>±1</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = Dirichlet(Chebyshev())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteDirichlet : Chebyshev() → 2-element ArraySpace:
ConstantSpace{Point{Float64}, Float64}[ConstantSpace(Point(-1.0)), ConstantSpace(Point(1.0))] 1.0  -1.0  1.0  -1.0  1.0  -1.0  1.0  -1.0  1.0  -1.0  ⋯
 1.0   1.0  1.0   1.0  1.0   1.0  1.0   1.0  1.0   1.0  ⋯</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; size(B)</code><code class="nohighlight hljs ansi" style="display:block;">(2, ℵ₀)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B*Fun(exp)</code><code class="nohighlight hljs ansi" style="display:block;">Fun(2-element ArraySpace:
ConstantSpace{Point{Float64}, Float64}[ConstantSpace(Point(-1.0)), ConstantSpace(Point(1.0))], [0.3678794411714403, 2.718281828459044])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B*Fun(exp) ≈ Fun([exp(-1),exp(1)])</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Multiplication"><a class="docs-heading-anchor" href="#Multiplication">Multiplication</a><a id="Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplication" title="Permalink"></a></h2><p>A <code>Multiplication</code> operator sends a <code>Fun</code> to a <code>Fun</code> in the corresponding space by multiplying a given function. The <code>Multiplication</code> operators are presented in matrix form in <code>ApproxFun</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = Fun();</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = Multiplication(1 + 2x + x^2, Chebyshev())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteMultiplication : Chebyshev() → Chebyshev() 1.5  1.0   0.25   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    ⋅
 2.0  1.75  1.0   0.25   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    ⋅
 0.5  1.0   1.5   1.0   0.25   ⋅     ⋅     ⋅     ⋅     ⋅    ⋅
  ⋅   0.25  1.0   1.5   1.0   0.25   ⋅     ⋅     ⋅     ⋅    ⋅
  ⋅    ⋅    0.25  1.0   1.5   1.0   0.25   ⋅     ⋅     ⋅    ⋅
  ⋅    ⋅     ⋅    0.25  1.0   1.5   1.0   0.25   ⋅     ⋅    ⋅
  ⋅    ⋅     ⋅     ⋅    0.25  1.0   1.5   1.0   0.25   ⋅    ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅    0.25  1.0   1.5   1.0   0.25  ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅    0.25  1.0   1.5   1.0   ⋱
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.25  1.0   1.5   ⋱
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋱     ⋱    ⋱</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (M * x).coefficients == ((1 + 2x + x^2) * x).coefficients == M[1:4,1:2] * x.coefficients</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>It is possible for domain space and range space to be different under <code>Mulitplication</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Fun(θ -&gt; cos(θ), CosSpace());</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Multiplication(c, SinSpace())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteMultiplication : SinSpace(【0.0,6.283185307179586❫) → SinSpace(【0.0,6.283185307179586❫) 8.974302782386682e-17  0.5                    …   ⋅                     ⋅
 0.5                    8.974302782386682e-17      ⋅                     ⋅
  ⋅                     0.5                        ⋅                     ⋅
  ⋅                      ⋅                         ⋅                     ⋅
  ⋅                      ⋅                         ⋅                     ⋅
  ⋅                      ⋅                     …   ⋅                     ⋅
  ⋅                      ⋅                         ⋅                     ⋅
  ⋅                      ⋅                         ⋅                     ⋅
  ⋅                      ⋅                        0.5                    ⋅
  ⋅                      ⋅                        8.974302782386682e-17  ⋱
  ⋅                      ⋅                     …   ⋱                     ⋱</code></pre><p>If a function is given by the expansion</p><p class="math-container">\[\mathop{f}(θ) = \sum_{n=1}^∞  f_n \sin{nθ}.\]</p><p>Then the matrix above can be easily derived from</p><p class="math-container">\[\begin{aligned}
\cos{θ} \mathop{f}(θ) &amp;= \cos{θ} \sum_{n=1}^∞ f_n \sin{nθ} \\
                          &amp;= \sum_{n=1}^∞ f_n \cos{θ} \sin{nθ} \\
                          &amp;= \sum_{n=1}^∞ \frac{1}{2} f_n \left(\sin{(n-1)θ} + \sin{(n+1)θ}\right) \\
                          &amp;= \sum_{n=1}^∞ \frac{1}{2} \left(f_{n-1} + f_{n+1}\right) \sin{nθ},
\end{aligned}\]</p><p>where <span>$f_0 = 0$</span>.</p><h2 id="Algebraic-manipulation-of-operators"><a class="docs-heading-anchor" href="#Algebraic-manipulation-of-operators">Algebraic manipulation of operators</a><a id="Algebraic-manipulation-of-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-manipulation-of-operators" title="Permalink"></a></h2><p>Operators can be algebraically manipulated, provided that the domain and range spaces are compatible, or can be made compatible.  As a simple example, we can add the second derivative of a Fourier space to the identity operator:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; D2 = Derivative(Fourier(),2)</code><code class="nohighlight hljs ansi" style="display:block;">DerivativeWrapper : Fourier(【0.0,6.283185307179586❫) → Fourier(【0.0,6.283185307179586❫) 0.0    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅   -1.0    ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅     ⋅   -1.0    ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅     ⋅     ⋅   -4.0    ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅   -4.0    ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅   -9.0    ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   -9.0     ⋅      ⋅      ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   -16.0     ⋅      ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅   -16.0     ⋅   ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅   -25.0  ⋅
  ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋱</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D2 + I</code><code class="nohighlight hljs ansi" style="display:block;">PlusOperator : Fourier(【0.0,6.283185307179586❫) → Fourier(【0.0,6.283185307179586❫) 1.0   ⋅    ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅   0.0   ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅    ⋅   0.0    ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅    ⋅    ⋅   -3.0    ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅    ⋅    ⋅     ⋅   -3.0    ⋅     ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅    ⋅    ⋅     ⋅     ⋅   -8.0    ⋅      ⋅      ⋅      ⋅   ⋅
  ⋅    ⋅    ⋅     ⋅     ⋅     ⋅   -8.0     ⋅      ⋅      ⋅   ⋅
  ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅   -15.0     ⋅      ⋅   ⋅
  ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅      ⋅   -15.0     ⋅   ⋅
  ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅   -24.0  ⋅
  ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅      ⋅      ⋅      ⋅   ⋱</code></pre><p>When the domain and range space are not the same, the identity operator becomes a conversion operator.  That is, to represent <code>D+I</code> acting on the Chebyshev space, we would do the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = Derivative(Chebyshev())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteDerivative : Chebyshev() → Ultraspherical(1) ⋅  1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅   2.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅   3.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅   4.0   ⋅    ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅   5.0   ⋅    ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅   6.0   ⋅    ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   7.0   ⋅    ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   8.0   ⋅   ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   9.0  ⋅
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋱
 ⋅   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   ⋱</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = Conversion(Chebyshev(),Ultraspherical(1))</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteConversion : Chebyshev() → Ultraspherical(1) 1.0  0.0  -0.5    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅   0.5   0.0  -0.5    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅    0.5   0.0  -0.5    ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅    0.5   0.0  -0.5    ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅    0.5   0.0  -0.5    ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅    0.5   0.0  -0.5    ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅    0.5   0.0  -0.5    ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.5   0.0  -0.5  ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.5   0.0  ⋱
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.5  ⋱
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋱</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D + C</code><code class="nohighlight hljs ansi" style="display:block;">PlusOperator : Chebyshev() → Ultraspherical(1) 1.0  1.0  -0.5    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅   0.5   2.0  -0.5    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅    0.5   3.0  -0.5    ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅    0.5   4.0  -0.5    ⋅     ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅    0.5   5.0  -0.5    ⋅     ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅    0.5   6.0  -0.5    ⋅     ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅    0.5   7.0  -0.5    ⋅   ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.5   8.0  -0.5  ⋅
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.5   9.0  ⋱
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅    0.5  ⋱
  ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋱</code></pre><p>ApproxFun can automatically determine the spaces, so if one writes <code>D + I</code> it will translate it to <code>D + C</code>.  </p><p>Now consider the Fredholm integral operator of the second kind:</p><p class="math-container">\[\mathop{L} \mathop{u} = \mathop{u} + \mathop{e}^x \int_{-1}^1 \mathop{u}(x) \mathop{dx}.\]</p><p>We can construct this using</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = Fun();</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Σ = DefiniteIntegral(Chebyshev())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteDefiniteIntegral : Chebyshev() → ConstantSpace 2.0  0.0  -0.6666666666666666  0.0  …  0.0  -0.031746031746031744  0.0  ⋯</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; L = I + exp(x)*Σ</code><code class="nohighlight hljs ansi" style="display:block;">LowRankPertOperator : Chebyshev() → Chebyshev() 3.5321317555040164     0.0  …  -0.0401925675476828      0.0  ⋯
 2.2606364159699406     1.0     -0.03588311771380858     0.0  ⋱
 0.5429906790681532     0.0     -0.008618899667748463    0.0  ⋱
 0.08867369969732763    0.0     -0.0014075190428147243   0.0  ⋱
 0.010948480884187472   0.0     -0.00017378541086011858  0.0  ⋱
 0.0010858526238278882  0.0  …  -1.7235755933776e-5      0.0  ⋱
 8.995464590859037e-5   0.0     -1.4278515223585772e-6   0.0  ⋱
 6.396872924803985e-6   0.0     -1.0153766547307912e-7   0.0  ⋱
 3.9842496133455947e-7  0.0      0.9999999936757943      0.0  ⋱
 2.2073543451034698e-8  0.0     -3.5037370557197933e-10  1.0  ⋱
  ⋮                      ⋱   …    ⋱                       ⋱   ⋱</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = cos(10x^2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (L*u)(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">1.3777980523127369</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u(0.1) + exp(0.1)*sum(u)</code><code class="nohighlight hljs ansi" style="display:block;">1.377798052312737</code></pre><p>Note that <code>DefiniteIntegral</code> is a functional, i.e., a 1 × ∞ operator.  when multiplied on the left by a function, it automatically constructs the operator <span>$\mathop{e}^x \int_{-1}^1 \mathop{f}(x) \mathop{dx}$</span> via</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = Multiplication(exp(x),ConstantSpace())</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteMultiplication : ConstantSpace → Chebyshev() 1.2660658777520082
 1.1303182079849703
 0.2714953395340766
 0.04433684984866382
 0.005474240442093736
 0.0005429263119139441
 4.497732295429518e-5
 3.1984364624019926e-6
 1.9921248066727974e-7
 1.1036771725517349e-8
  ⋮</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M*Σ</code><code class="nohighlight hljs ansi" style="display:block;">TimesOperator : Chebyshev() → Chebyshev() 2.5321317555040164     0.0  …  -0.0401925675476828      0.0  ⋯
 2.2606364159699406     0.0     -0.03588311771380858     0.0  ⋱
 0.5429906790681532     0.0     -0.008618899667748463    0.0  ⋱
 0.08867369969732763    0.0     -0.0014075190428147243   0.0  ⋱
 0.010948480884187472   0.0     -0.00017378541086011858  0.0  ⋱
 0.0010858526238278882  0.0  …  -1.7235755933776e-5      0.0  ⋱
 8.995464590859037e-5   0.0     -1.4278515223585772e-6   0.0  ⋱
 6.396872924803985e-6   0.0     -1.0153766547307912e-7   0.0  ⋱
 3.9842496133455947e-7  0.0     -6.324205735469197e-9    0.0  ⋱
 2.2073543451034698e-8  0.0     -3.5037370557197933e-10  0.0  ⋱
  ⋮                      ⋱   …    ⋱                       ⋱   ⋱</code></pre><p>Note that <code>Σ*exp(x)</code> applies the operator to a function.  To construct the operator that first multiplies by <code>exp(x)</code>, use <code>Σ[exp(x)]</code>.  This is equivalent to <code>Σ*Multiplication(exp(x),Chebyshev())</code>.</p><h2 id="Operators-and-space-promotion"><a class="docs-heading-anchor" href="#Operators-and-space-promotion">Operators and space promotion</a><a id="Operators-and-space-promotion-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-and-space-promotion" title="Permalink"></a></h2><p>It is often more convenient to not specify a space explicitly, but rather infer it when the operator is used.  For example, we can construct <code>Derivative()</code>, which has the alias <code>𝒟</code>, and represents the first derivative on any space:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = Fun(cos,Chebyshev(0..1)); (𝒟*f)(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">-0.09983341664681751</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = Fun(cos,Fourier()); (𝒟*f)(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">-0.09983341664682804</code></pre><p>Behind the scenes, <code>Derivative()</code> is equivalent to <code>Derivative(UnsetSpace(),1)</code>.  When multiplying a function <code>f</code>, the domain space is promoted before multiplying, that is, <code>Derivative()*f</code> is equivalent to <code>Derivative(space(f))*f</code>.  </p><p>This promotion of the domain space happens even when operators have spaces attached.  This facilitates the following construction:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = Derivative(Chebyshev());</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D^2</code><code class="nohighlight hljs ansi" style="display:block;">ConcreteDerivative : Chebyshev() → Ultraspherical(2) ⋅  ⋅  4.0   ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
 ⋅  ⋅   ⋅   6.0   ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
 ⋅  ⋅   ⋅    ⋅   8.0    ⋅     ⋅     ⋅     ⋅     ⋅   ⋅
 ⋅  ⋅   ⋅    ⋅    ⋅   10.0    ⋅     ⋅     ⋅     ⋅   ⋅
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅   12.0    ⋅     ⋅     ⋅   ⋅
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅     ⋅   14.0    ⋅     ⋅   ⋅
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅     ⋅     ⋅   16.0    ⋅   ⋅
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅   18.0  ⋅
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋱
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋱
 ⋅  ⋅   ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅     ⋅   ⋱</code></pre><p>Note that <code>rangespace(D) ≠ Chebyshev()</code>, hence the operators are not compatible.  Therefore, it has thrown away its domain space, and thus this is equivalent to <code>Derivative(rangespace(D))*D</code>.</p><h2 id="Concatenating-operators"><a class="docs-heading-anchor" href="#Concatenating-operators">Concatenating operators</a><a id="Concatenating-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenating-operators" title="Permalink"></a></h2><p>The concatenation functions <code>vcat</code>, <code>hcat</code> and <code>hvcat</code> are overriden for operators to represent the resulting combined operator, now with a <code>rangespace</code> or <code>domainspace</code> that is an <code>ArraySpace</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constructors/">« Constructors</a><a class="docs-footer-nextpage" href="../equations/">Linear Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 20 August 2022 16:29">Saturday 20 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
