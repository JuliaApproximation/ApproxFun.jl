var documenterSearchIndex = {"docs":
[{"location":"internals/blocks/#Blocks","page":"Blocks","title":"Blocks","text":"","category":"section"},{"location":"internals/blocks/","page":"Blocks","title":"Blocks","text":"Every space is divided into blocks, which are used to indicate, for example, polynomial degree.  The prototypical examples have trivial blocks, for example Taylor() and Chebyshev() have blocks of length 1, as each coefficient corresponds to a higher polynomial degree.","category":"page"},{"location":"internals/blocks/","page":"Blocks","title":"Blocks","text":"Usually, non-trivial block lengths arise from modifications of the spaces with trivial blocks.  For example, Chebyshev(0..1) ∪ Chebyshev(2..3) has blocks of length 2, as the blocks of each component space are grouped together to form a single block.  Another important example is Chebyshev() ⊗ Chebyshev(), the tensor product space.  There are d polynomials of degree d, thus the blocks of a tensor product space grow: that is, the first block has length 1, then 2, and so on.","category":"page"},{"location":"internals/blocks/","page":"Blocks","title":"Blocks","text":"blocklengths(::Space) gives an iterator that encodes the lengths of the blocks. For trivial blocks, this will return Ones{Int}(∞).  For Chebyshev(0..1) ∪ Chebyshev(2..3) it returns Fill(2,∞). For Chebyshev() ⊗ Chebyshev() it returns InfiniteArrays.OneToInf().","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"EditURL = \"../../../examples/ODE.jl\"","category":"page"},{"location":"generated/ODE/#Solving-ODEs","page":"Solving ODEs","title":"Solving ODEs","text":"","category":"section"},{"location":"generated/ODE/#Boundary-value-problem","page":"Solving ODEs","title":"Boundary value problem","text":"","category":"section"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We solve the Airy equation","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"fracd^2 ydx^2-x y = 0","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"in an interval a..b, subject to the boundary conditions y(a)=mathrmAi(a) and y(b)=mathrmAi(b), where mathrmAi represents the Airy function of the first kind.","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"using ApproxFun\nusing SpecialFunctions","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"Construct the domain","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"a, b = -20, 10\nd = a..b;\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We construct the Airy differential operator L = d^2dx^2 - x:","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"x = Fun(d);\nD = Derivative(d);\nL = D^2 - x;\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We impose boundary conditions by setting the function at the boundaries equal to the values of the Airy function at these points. First, we construct the Dirichlet boundary condition operator, that evaluates the function at the boundaries","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"B = Dirichlet(d);\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"The right hand side for the boundary condition is obtained by evaluating the Airy function We use airyai from SpecialFunctions.jl for this","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"B_vals = [airyai(a), airyai(b)];\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"The main step, where we solve the differential equation","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"u = [B; L] \\ [B_vals, 0];\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We plot the solution","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"import Plots\nPlots.plot(u, xlabel=\"x\", ylabel=\"u(x)\", legend=false)","category":"page"},{"location":"generated/ODE/#Initial-value-problem","page":"Solving ODEs","title":"Initial value problem","text":"","category":"section"},{"location":"generated/ODE/#Undamped-harmonic-oscillator","page":"Solving ODEs","title":"Undamped harmonic oscillator","text":"","category":"section"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"fracd^2 udt^2 + 4 u = 0","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"in an interval 0..2pi, subject to the initial conditions u(0)=0 and u(0)=2.","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"using ApproxFun\nusing LinearAlgebra","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"Construct the domain","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"a, b = 0, 2pi\nd = a..b;\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We construct the differential operator L = d^2dx^2 + 4:","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"D = Derivative(d)\nL = D^2 + 4;\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We have not chosen the space explicitly, and the solve chooses it to be Chebyshev(d) internally","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We incorporate the initial conditions using ivp, which is a shortcut for evaluating the function and it's derivative at the left boundary of the domain","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"A = [L; ivp()];\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"Initial conditions","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"u0 = 0;\ndtu0 = 2;\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We solve the differential equation","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"u = \\(A, [0,u0,dtu0], tolerance=1e-6);\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We plot the solution","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"t = a:0.1:b\nPlots.plot(t, u.(t), xlabel=\"t\", label=\"u(t)\")\nPlots.plot!(t, sin.(2t), label=\"Analytical\", seriestype=:scatter)","category":"page"},{"location":"generated/ODE/#Damped-harmonic-oscillator","page":"Solving ODEs","title":"Damped harmonic oscillator","text":"","category":"section"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"fracd^2 ydt^2 + 2zetaomega_0fracdydt + omega_0^2 y = 0","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"from t=0 to t=T, subject to the initial conditions y(0)=4 and y(0)=0.","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"Construct the domain","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"T = 12\nd = 0..T;\n\nDt = Derivative(d);\nζ = 0.2 # damping ratio\nω0 = 2 # oscillation frequency\nL = Dt^2 + 2ζ * ω0 * Dt + ω0^2;\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"initial conditions","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"y0 = 4; # initial displacement\ndty0 = 3; # initial velocity\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"The differential operator along with the initial condition evaluation operator","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"A = [L; ivp()];\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"We solve the differential equation","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"y = \\(A, [0,y0,dty0], tolerance=1e-6);\nnothing #hide","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"Plot the solution","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"import Plots\nPlots.plot(y, xlabel=\"t\", ylabel=\"y(t)\", legend=false)","category":"page"},{"location":"generated/ODE/#Increasing-Precision","page":"Solving ODEs","title":"Increasing Precision","text":"","category":"section"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"Solving differential equations with high precision types is available. The following calculates e to 300 digits by solving the ODE u^prime = u:","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"using ApproxFun\nu = setprecision(1000) do\n    d = BigFloat(0)..BigFloat(1)\n    D = Derivative(d)\n    [ldirichlet(); D-1] \\ [1; 0]\nend;\n\nimport Plots\nPlots.plot(u; legend=false, xlabel=\"x\", ylabel=\"u(x)\")","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"","category":"page"},{"location":"generated/ODE/","page":"Solving ODEs","title":"Solving ODEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"EditURL = \"../../../examples/system_of_eqn.jl\"","category":"page"},{"location":"generated/system_of_eqn/#System-of-equations","page":"System of equations","title":"System of equations","text":"","category":"section"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"Systems of equations can be handled by creating a matrix of operators and functionals. For example, we can solve the system","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"begingathered\n    mathopu - mathopu + 2 mathopv = mathope^x  \n    mathopu + mathopv + mathopv = cosx \n    mathopu(-1) = mathopu(-1) = mathopv(-1) = 0\nendgathered","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"using the following code:","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"using ApproxFun\nusing LinearAlgebra\n\nx = Fun();\nB = Evaluation(Chebyshev(),-1);\nA = [B      0;\n     B*𝒟    0;\n     0      B;\n     𝒟^2-I  2I;\n     I      𝒟+I];\nu,v = A \\ [0;0;0;exp(x);cos(x)];\n\n\nimport Plots\nPlots.plot(u, label=\"u\", xlabel=\"x\", legend=:topleft)\nPlots.plot!(v, label=\"v\")","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"In this example, the automatic space detection failed and so we needed to specify explicitly that the domain space for B is Chebyshev().","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"","category":"page"},{"location":"generated/system_of_eqn/","page":"System of equations","title":"System of equations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"EditURL = \"../../../examples/Eigenvalue.jl\"","category":"page"},{"location":"generated/Eigenvalue/#Eigenvalue-problem","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"","category":"section"},{"location":"generated/Eigenvalue/#Standard-eigenvalue-problem","page":"Eigenvalue problem","title":"Standard eigenvalue problem","text":"","category":"section"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"In analogy to linear algebra, many differential equations may be posed as eigenvalue problems. That is, for some differential operator mathopL, there are a family of functions mathopu_i(x) such that","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"mathopL mathopu_i(x) = λ_i mathopu_i(x)","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"where λ_i is the i^th eigenvalue of the L and has a corresponding eigenfunction mathopu_i(x).","category":"page"},{"location":"generated/Eigenvalue/#Quantum-harmonic-oscillator","page":"Eigenvalue problem","title":"Quantum harmonic oscillator","text":"","category":"section"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"A classic eigenvalue problem is known as the quantum harmonic oscillator where","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"mathopL = -frac12fracmathopd^2mathopdx^2 + frac12 x^2","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"and one demands that mathopu() = mathopu(-) = 0. Because we expect the solutions to be exponentially suppressed for large x, we can approximate this with Dirichlet boundary conditions at a 'reasonably large' x without much difference.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We can express this in ApproxFun as the following:","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"using ApproxFun\n\nx = Fun(-8..8)\nV = x^2/2\nL = -𝒟^2/2 + V\nS = space(x)\nB = Dirichlet(S)\nλ, v = ApproxFun.eigs(B, L, 500,tolerance=1E-10);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Note that boundary conditions must be specified in the call to eigs. Plotting the first 20 eigenfunctions offset vertically by their eigenvalue, we see","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"import Plots\nusing LinearAlgebra: norm\np = Plots.plot(V, legend=false, ylim=(-Inf, λ[22]))\nfor k=1:20\n    Plots.plot!(real(v[k]) + real(λ[k]))\nend\np","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"If the solutions are not relatively constant near the boundary then one should push the boundaries further out.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"For problems with different contraints or boundary conditions, B can be any zero functional constraint, e.g., DefiniteIntegral().","category":"page"},{"location":"generated/Eigenvalue/#Self-adjoint-Eigenvalue-Problem","page":"Eigenvalue problem","title":"Self-adjoint Eigenvalue Problem","text":"","category":"section"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Ref: J. L. Aurentz & R. M. Slevinsky (2019), arXiv:1903.08538","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We solve the confined anharmonic oscillator","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"left-fracd^2dx^2 + V(x)right u = λu","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"where u(pm 10) = 0, V(x) = ωx^2 + x^4, and ω = 25.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"using ApproxFun\nusing LinearAlgebra\nusing BandedMatrices","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Define parameters","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"ω = 25.0\nd = -10..10;\nS = Legendre(d); # Equivalently, Ultraspherical(0.5, d)\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Construct the differential operator","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"V = Fun(x -> ω * x^2 + x^4, S)\nL = -Derivative(S, 2) + V;\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Boundary conditions that are used in the basis recombination","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"B = Dirichlet(S);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"The system may be recast as a generalized eigenvalue problem A_Sv = λ B_S v, where A_S and B_S are symmetric band matrices. We wrap the operators in SymmetricEigensystem to implicitly perform the basis recombination","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"SEg = ApproxFun.SymmetricEigensystem(L, B);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We construct n × n matrix representations of the opertors that we diagonalize","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"n = 3000\nλ = eigvals(SEg, n);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We retain a fraction of the eigenvalues with the least magnitude","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"λ = λ[1:round(Int, 3n/5)];\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We plot the eigenvalues","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"import Plots\nPlots.plot(λ, title = \"Eigenvalues\", legend=false)","category":"page"},{"location":"generated/Eigenvalue/#Infinite-well-with-a-barrier","page":"Eigenvalue problem","title":"Infinite well with a barrier","text":"","category":"section"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We solve the Schrodinger equation in an infinite square well in the domain -Lx/2..Lx/2, with a finite barrier in the middle from -d/2..d/2","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"mathopL = -frac12fracmathopd^2mathopdx^2 + V(x)","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"where V(x) is given by an infinite well with a smoothed barrier at the center.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We note that the system has parity symmetry, so the solutions may be separated into odd and even functions. We may therefore solve the problem only for half the domain, with Dirichlet boundary conditions at the midpoint for odd functions, and Neumann conditions for even functions. This projection to subspaces allows us to halve the sizes of matrices that we need to diagonalize","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Lx = 4 # size of the domain\nS = Legendre(0..Lx/2)\nx = Fun(S)\nd = 1 # size of the barrier\nΔ = 0.1 # smoothing scale of the barrier\nV = 50 * (1 - tanh((x - d/2)/Δ))/2; # right half of the potential barrier\nH = -Derivative(S)^2/2 + V;\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Odd solutions, with a zero Dirichlet condition at 0 representing a node","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"B = Dirichlet(S);\nSeig = ApproxFun.SymmetricEigensystem(H, B);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Diagonalize n × n matrix representations of the basis-recombined operators We specify a tolerance to reject spurious solutions arising from the discretization","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"n = 100\nλodd, vodd = ApproxFun.eigs(Seig, n, tolerance=1e-8);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"To extend the solutions to the full domain, we construct the left-half space.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Scomplement = Legendre(-Lx/2..0);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We use the fact that Legendre polynomials of odd orders are odd functions, and those of even orders are even functions Using this, for the odd solutions, we negate the even-order coefficients to construct the odd image in -Lx/2..0","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"function oddimage(f, Scomplement)\n    coeffs = [(-1)^isodd(m) * c for (m,c) in enumerate(coefficients(f))]\n    Fun(Scomplement, coeffs)\nend\nvoddimage = oddimage.(vodd, Scomplement);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Construct the functions over the entire domain -Lx/2..Lx/2 as piecewise sums over the two half domains -Lx/2..0 and 0..Lx/2 The eigenfunctions vodd are normalized on the half-domain, so we normalize the sum by dividing it by √2","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"voddfull = (voddimage .+ vodd)./√2;\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Even solutions, with a Neumann condition at 0 representing the symmetry of the function","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"B = [lneumann(S); rdirichlet(S)];\n\nSeig = ApproxFun.SymmetricEigensystem(H, B);\nλeven, veven = ApproxFun.eigs(Seig, n, tolerance=1e-8);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"For the even solutions, we negate the odd-order coefficients to construct the even image in -Lx/2..0","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"function evenimage(f, Scomplement)\n    coeffs = [(-1)^iseven(m) * c for (m,c) in enumerate(coefficients(f))]\n    Fun(Scomplement, coeffs)\nend\nvevenimage = evenimage.(veven, Scomplement);\nvevenfull = (vevenimage .+ veven)./√2;\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We interlace the eigenvalues and eigenvectors to obtain the entire spectrum","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"function interlace(a::AbstractVector, b::AbstractVector)\n    vec(permutedims([a b]))\nend\nλ = interlace(λeven, λodd);\nv = interlace(vevenfull, voddfull);\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Symmetrize the potential using an even image (this is mainly for plotting/post-processing)","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Vevenimage = evenimage(V, Scomplement);\nVfull = Vevenimage + V;\nnothing #hide","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"We plot the first few eigenfunctions offset by their eigenvalues. The eigenfunctions appear in odd-even pairs by construction.","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"import Plots\nusing LinearAlgebra: norm\np1 = Plots.plot(Vfull, legend=false, ylim=(-Inf, λ[14]), title=\"Eigenfunctions\",\n    seriestype=:path, linestyle=:dash, linewidth=2)\nPlots.vline!([-Lx/2, Lx/2], color=:black)\nfor k=1:12\n    Plots.plot!(real(v[k]) + λ[k])\nend","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"Zoom into the ground state:","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"p2 = Plots.plot(Vfull, legend=false, ylim=(-Inf, λ[3]), title=\"Ground state\",\n    seriestype=:path, linestyle=:dash, linewidth=2)\nPlots.vline!([-Lx/2, Lx/2], color=:black)\nPlots.plot!(real(v[1]) + λ[1], linewidth=2)\n\nPlots.plot(p1, p2, layout = 2)","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"","category":"page"},{"location":"generated/Eigenvalue/","page":"Eigenvalue problem","title":"Eigenvalue problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"DocTestSetup  = quote\n    using ApproxFun, LinearAlgebra\nend","category":"page"},{"location":"usage/spaces/#Spaces","page":"Spaces","title":"Spaces","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"A Space is an abstract type whose subtypes indicate which space a function lives in. This typically corresponds to the span of a (possibly infinite) basis.","category":"page"},{"location":"usage/spaces/#Classical-orthogonal-polynomial-spaces","page":"Spaces","title":"Classical orthogonal polynomial spaces","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Chebyshev, Ultraspherical, Jacobi, Hermite, and Laguerre are spaces corresponding to expansion in classical orthogonal polynomials.","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Note that we always use the classical normalization: the basis are not orthonormal.  This is because this normalization leads to rational recurrence relationships, which are more efficient than their normalized counterparts. See the Digital Library of Mathematical Functions for more information.","category":"page"},{"location":"usage/spaces/#Chebyshev-space","page":"Spaces","title":"Chebyshev space","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"The default space in ApproxFun is Chebyshev, which represents expansions in Chebyshev polynomials:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(x) = sum_k=0^ f_k mathopT_k(x)","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"where mathopT_k(x) = cos(karccosx), which are orthogonal polynomials with respect to the weight","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"frac1sqrt1-x^2 quadtextforquad -1  x  1","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Note that there is an intrinsic link between Chebyshev and CosSpace:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopg(θ) = mathopf(cosθ) = sum_k=0^ f_k coskθ","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"In other words:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"julia> f = Fun(exp, Chebyshev());\n\njulia> g = Fun(CosSpace(), coefficients(f));  # specify the coefficients directly\n\njulia> f(cos(0.1)) ≈ exp(cos(0.1))\ntrue\n\njulia> g(0.1) ≈ exp(cos(0.1))\ntrue","category":"page"},{"location":"usage/spaces/#Ultraspherical-spaces","page":"Spaces","title":"Ultraspherical spaces","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"A key tool for solving differential equations are the ultraspherical spaces, encoded as Ultraspherical(λ) for λ ≠ 0, which can be defined by the span of derivatives of Chebyshev polynomials, or alternatively as polynomials orthogonal with respect to the weight (1-x^2)^λ - frac12 for -1  x  1.","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Note that Ultraspherical(1) corresponds to the Chebyshev basis of the second kind: mathopU_k(x) = fracsin((k+1)arccosx)sin(arccosx).  The relationship with Chebyshev polynomials follows from trigonemetric identities: mathopT_k(x) = k mathopU_k-1(x).","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Converting between ultraspherical polynomials (with integer orders) is extremely efficient: it requires mathopO(n) operations, where n is the number of coefficients.","category":"page"},{"location":"usage/spaces/#Jacobi-spaces","page":"Spaces","title":"Jacobi spaces","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Jacobi(b,a) represents the space spanned by the Jacobi polynomials, which are orthogonal polynomials with respect to the weight","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"(1+x)^b(1-x)^a","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"using the standard normalization.","category":"page"},{"location":"usage/spaces/#Fourier-and-Laurent-spaces","page":"Spaces","title":"Fourier and Laurent spaces","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"There are several different spaces to represent functions on periodic domains, which are typically a PeriodicSegment, Circle or PeriodicLine.","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"CosSpace represents expansion in cosine series:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(θ) = sum_k=0^ f_k coskθ","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"SinSpace represents expansion in sine series:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(θ) = sum_k=0^ f_k sin(k+1)θ","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Fourier represents functions that are sums of sines and cosines.  Note that if a function has the form","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(θ) = f_0 + sum_k=1^ left(f_k^mathrms sinkθ + f_k^mathrmc coskθright)","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"then the coefficients of the resulting Fun are ordered as f_0 f_1^mathrms f_1^mathrmc .  For example:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"julia> f = Fun(Fourier(), [1,2,3,4]);\n\njulia> f(0.1) ≈ 1 + 2sin(0.1) + 3cos(0.1) + 4sin(2*0.1)\ntrue","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Taylor represents expansion with only non-negative complex exponential terms:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(θ) = sum_k=0^ f_k mathope^ikθ","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Hardy{false} represents expansion with only negative complex exponential terms:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(θ) = sum_k=0^ f_k mathope^-i(k+1)θ","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Laurent represents functions that are sums of complex exponentials.  Note that if a function has the form","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopf(θ) = sum_k=-^ f_k mathope^ikθ","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"then the coefficients of the resulting Fun are order as f_0 f_-1 f_1 .  For example:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"julia> f = Fun(Laurent(), [1,2,3,4]);\n\njulia> f(0.1) ≈ 1 + 2exp(-im*0.1) + 3exp(im*0.1) + 4exp(-2im*0.1)\ntrue","category":"page"},{"location":"usage/spaces/#Modifier-spaces","page":"Spaces","title":"Modifier spaces","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Some spaces are built out of other spaces:","category":"page"},{"location":"usage/spaces/#JacobiWeight","page":"Spaces","title":"JacobiWeight","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"JacobiWeight(β,α,space)  weights space, which is typically Chebyshev() or Jacobi(b,a), by a Jacobi weight (1+x)^α*(1-x)^β: in other words, if the basis for space is mathopψ_k(x) and the domain is the unit interval -1..1, then the basis for JacobiWeight(β,α,space) is (1+x)^α(1-x)^β mathopψ_k(x). If the domain is not the unit interval, then the basis is determined by mapping back to the unit interval: that is, if mathopM(x) is the map dictated by tocanonical(space, x), where the canonical domain is the unit interval, then the basis is (1+mathopM(x))^α(1-mathopM(x))^β mathopψ_k(x). For example, if the domain is another interval a..b, then","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"mathopM(x) = frac2x-b-ab-a","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"and the basis becomes","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"left(frac2b-aright)^α+β  (x-a)^α (b-x)^β mathopψ_k(x)","category":"page"},{"location":"usage/spaces/#SumSpace","page":"Spaces","title":"SumSpace","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"SumSpace((space_1,space_2,…,space_n)) represents the direct sum of the spaces, where evaluation is defined by adding up each component. A simple example is the following, showing that the coefficients are stored by interlacing:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"julia> x = Fun(identity, -1..1);\n\njulia> f = cos(x-0.1)*sqrt(1-x^2) + exp(x);\n\njulia> space(f) == JacobiWeight(0.5, 0.5, Chebyshev(-1..1)) + Chebyshev(-1..1)\ntrue\n\njulia> a, b = components(f);\n\njulia> a(0.2) ≈ cos(0.2-0.1)*sqrt(1-0.2^2)\ntrue\n\njulia> b(0.2) ≈ exp(0.2)\ntrue\n\njulia> f(0.2) ≈ a(0.2) + b(0.2)\ntrue\n\njulia> norm(coefficients(f)[1:2:end] - coefficients(a))\n0.0\n\njulia> norm(coefficients(f)[2:2:end] - coefficients(b))\n0.0","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"More complicated examples may interlace the coefficients using a different strategy.  Note that it is difficult to represent the first component of function mathopf by a Chebyshev series because the derivatives of mathopf at its boundaries blow up, whereas the derivative of a polynomial is a polynomial.","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"Note that Fourier and Laurent are currently implemented as SumSpace, but this may change in the future.","category":"page"},{"location":"usage/spaces/#ArraySpace","page":"Spaces","title":"ArraySpace","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"ArraySpace(::Array{<:Space}) represents the direct sum of the spaces, where evaluation is defined in an array-wise manner.  A simple example is the following:","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"julia> x = Fun(identity, -1..1);\n\njulia> f = [exp(x); sqrt(1-x^2)*cos(x-0.1)];\n\njulia> space(f) isa ApproxFun.ArraySpace\ntrue\n\njulia> a, b = components(f);\n\njulia> norm(f(0.5) - [a(0.5); b(0.5)])\n0.0\n\njulia> norm(coefficients(f)[1:2:end] - coefficients(a))\n0.0\n\njulia> norm(coefficients(f)[2:2:end] - coefficients(b))\n0.0","category":"page"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"More complicated examples may interlace the coefficients using a different strategy.","category":"page"},{"location":"usage/spaces/#TensorSpace","page":"Spaces","title":"TensorSpace","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"TensorSpace((space_1,space_2)) represents the tensor product of two spaces. See the documentation of TensorSpace for more details on how the coefficients are interlaced. Note that more than two spaces is only partially supported.","category":"page"},{"location":"usage/spaces/#Unset-space","page":"Spaces","title":"Unset space","text":"","category":"section"},{"location":"usage/spaces/","page":"Spaces","title":"Spaces","text":"UnsetSpace is a special space that is used as a stand in when a space has not yet been determined, particularly by operators.","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"EditURL = \"../../../examples/PDE.jl\"","category":"page"},{"location":"generated/PDE/#Solving-PDEs","page":"Solving PDEs","title":"Solving PDEs","text":"","category":"section"},{"location":"generated/PDE/#Poisson-equation","page":"Solving PDEs","title":"Poisson equation","text":"","category":"section"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We solve the Poisson equation","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Δu(xy) = f(xy)","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"on the rectangle -1..1 × -1..1, with zero boundary conditions:","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"using ApproxFun\nusing LinearAlgebra\n\nd = (-1..1)^2\nx,y = Fun(d)\nf = exp.(-10(x+0.3)^2-20(y-0.2)^2)  # use broadcasting as exp(f) not implemented in 2D\nA = [Dirichlet(d); Laplacian()]\nu = A \\ [zeros(∂(d)); f];\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Using a QR Factorization reduces the cost of subsequent calls substantially","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"QR = qr(A)\nu = QR \\ [zeros(∂(d)); f];\n\n\nimport Plots\nPlots.plot(u; st=:surface, legend=false)","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Many PDEs have weak singularities at the corners, in which case it is beneficial to specify a tolerance to reduce the time, as:","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"\\(A, [zeros(∂(d)); f]; tolerance=1E-6);\nnothing #hide","category":"page"},{"location":"generated/PDE/#Helmholtz-Equation","page":"Solving PDEs","title":"Helmholtz Equation","text":"","category":"section"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We solve","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"(Δ + 100)u(xy) = 0","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"on the rectangle -1..1 × -1..1, subject to the condition that u=1 on the boundary of the domain.","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"using ApproxFun\nusing LinearAlgebra","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"The rectangular domain may be expressed as a tensor product of ChebyshevIntervals","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"d = ChebyshevInterval()^2;\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We construct the operator that collates the differential operator and boundary conditions","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"L = [Dirichlet(d); Laplacian()+100I];\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We compute the QR decomposition of the operator to speed up the solution","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Q = qr(L);\nApproxFunBase.resizedata!(Q,:,4000);\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"The boundary condition is a function that is equal to one on each edge","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"boundary_cond = ones(∂(d));\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Solve the differential equation. This function has weak singularities at the corner, so we specify a lower tolerance to avoid resolving these singularities completely","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"u = \\(Q, [boundary_cond; 0.]; tolerance=1E-7);\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Plot the solution","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"import Plots\nPlots.plot(u; st=:surface, legend=false)","category":"page"},{"location":"generated/PDE/#Heat-equation","page":"Solving PDEs","title":"Heat equation","text":"","category":"section"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We solve the heat equation","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"fracpartialpartial t u(xt) = fracpartial^2partial x^2 u(xt)","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"on the spatial domain -1..1 from t=0 to t=1, with zero boundary conditions, and the initial condition u(x0) = u_0(x), where we choose u_0(x) to be a sharp Gaussian.","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"using ApproxFun\nusing LinearAlgebra\n\ndx = -1..1;\ndt = 0..1;\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We construct a 2D domain that is the tensor product of x and t","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"d = dx × dt;\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"The initial condition","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"u0 = Fun(x->exp(-x^2/(2*0.2^2)), dx);\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We define the derivatives on the 2D domain","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Dx = Derivative(d,[1,0]);\nDt = Derivative(d,[0,1]);\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"The operator along with the initial and the boundary conditions","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"A = [Dt - Dx^2; I⊗ldirichlet(dt); bvp(dx)⊗I];\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"We collect the initial condition along with zeros for the two boundary conditions and the equation","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"rhs = [0.0; u0; 0.0; 0.0];\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Solve the equation with an arbitrary tolerance. A lower tolerance will increase accuracy at the expense of execution time","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"u = \\(A, rhs, tolerance=1e-4);\nnothing #hide","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"Plot the solution","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"import Plots\nxplot = -1:0.02:1\np = Plots.plot(xplot, u.(xplot, 0), label=\"t=0\", legend=true, linewidth=2)\nfor t in [0.05, 0.1, 0.2, 0.5, 0.8]\n\tPlots.plot!(xplot, u.(xplot, t), label=\"t=$t\")\nend\np","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"","category":"page"},{"location":"generated/PDE/","page":"Solving PDEs","title":"Solving PDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"EditURL = \"../../../examples/Periodic.jl\"","category":"page"},{"location":"generated/Periodic/#Periodic-Domains","page":"Periodic Domains","title":"Periodic Domains","text":"","category":"section"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"using ApproxFun\nusing LinearAlgebra","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"We may approximate a periodic function in Fourier space","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"f = Fun(cos, Fourier(-π..π))\nnorm(differentiate(f) + Fun(sin, Fourier(-π..π))) < 100eps()","category":"page"},{"location":"generated/Periodic/#Boundary-Value-Problems","page":"Periodic Domains","title":"Boundary Value Problems","text":"","category":"section"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"Due to the periodicity, Fourier representations allow for the asymptotic savings of 2/π in the number of coefficients that need to be stored compared with a Chebyshev representation.","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"ODEs can also be solved when the solution is periodic.","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"In this example, we solve","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"fracdydt + (1 + sin(cos(2t)))y = exp(sin(10t))","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"subject to periodic boundary conditions on the domain -pipi.","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"Solve the differential equation in Chebyshev space","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"s = Chebyshev(-π..π)\na = Fun(t-> 1+sin(cos(2t)),s)\nL = Derivative() + a\nf = Fun(t->exp(sin(10t)),s)\nB = periodic(s,0)\nuChebyshev = [B;L]\\[0.,f]\nncoefficients(uChebyshev)","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"Solve the differential equation in Fourier space","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"s = Fourier(-π..π)\na = Fun(t-> 1+sin(cos(2t)),s)\nL = Derivative() + a\nf = Fun(t->exp(sin(10t)),s)\nuFourier = L\\f\nncoefficients(uFourier)","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"We note that the number of coefficients in the Fourier space is lower than that in the Chebyshev space by a factor of approximately π/2","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"ncoefficients(uFourier)/ncoefficients(uChebyshev),2/π","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"We plot the solution","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"import Plots\nPlots.plot(uFourier, xlims=(-pi, pi), legend=false)","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"","category":"page"},{"location":"generated/Periodic/","page":"Periodic Domains","title":"Periodic Domains","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Domains","page":"Library","title":"Domains","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Arc","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Arc","page":"Library","title":"ApproxFunOrthogonalPolynomials.Arc","text":"Arc(c,r,(θ₁,θ₂))\n\nrepresents the arc centred at c with radius r from angle θ₁ to θ₂.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Circle","category":"page"},{"location":"library/#ApproxFunFourier.Circle","page":"Library","title":"ApproxFunFourier.Circle","text":"Circle(c,r,o)\n\nrepresents the circle centred at c with radius r which is positively (o=true) or negatively (o=false) oriented.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Curve","category":"page"},{"location":"library/#ApproxFun.Curve","page":"Library","title":"ApproxFun.Curve","text":"Curve Represents a domain defined by the image of a Fun.  Example usage would be\n\nx=Fun(1..2)\nCurve(exp(im*x))  # represents an arc\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Segment","category":"page"},{"location":"library/#ApproxFunBase.Segment","page":"Library","title":"ApproxFunBase.Segment","text":"Segment(a,b)\n\nrepresents a line segment from a to b.  In the case where a and b are real and a < b, then this is is equivalent to an Interval(a,b).\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Interval","category":"page"},{"location":"library/#IntervalSets.Interval","page":"Library","title":"IntervalSets.Interval","text":"An Interval{L,R}(left, right) where L,R are :open or :closed is an interval set containg x such that\n\nleft ≤ x ≤ right if L == R == :closed\nleft < x ≤ right if L == :open and R == :closed\nleft ≤ x < right if L == :closed and R == :open, or\nleft < x < right if L == R == :open\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Line","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Line","page":"Library","title":"ApproxFunOrthogonalPolynomials.Line","text":"Line{a}(c)\n\nrepresents the line at angle a in the complex plane, centred at c.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"PeriodicSegment","category":"page"},{"location":"library/#ApproxFunFourier.PeriodicSegment","page":"Library","title":"ApproxFunFourier.PeriodicSegment","text":"PeriodicSegment(a,b)\n\nrepresents a periodic interval from a to b, that is, the point b is identified with a.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ApproxFun.Point","category":"page"},{"location":"library/#DomainSets.Point","page":"Library","title":"DomainSets.Point","text":"Point(x)\n\nrepresents a single point at x.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ProductDomain","category":"page"},{"location":"library/#DomainSets.ProductDomain","page":"Library","title":"DomainSets.ProductDomain","text":"A ProductDomain represents the cartesian product of other domains.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Ray","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Ray","page":"Library","title":"ApproxFunOrthogonalPolynomials.Ray","text":"Ray{a}(c,L,o)\n\nrepresents a scaled ray (with scale factor L) at angle a starting at c, with orientation out to infinity (o = true) or back from infinity (o = false).\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"UnionDomain","category":"page"},{"location":"library/#DomainSets.UnionDomain","page":"Library","title":"DomainSets.UnionDomain","text":"A UnionDomain represents the union of a set of domains.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"∂","category":"page"},{"location":"library/#DomainSets.∂","page":"Library","title":"DomainSets.∂","text":"Return the boundary of the given domain as a domain.\n\n\n\n\n\n","category":"function"},{"location":"library/#Accessing-information-about-a-spaces","page":"Library","title":"Accessing information about a spaces","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"ApproxFunBase.canonicalspace","category":"page"},{"location":"library/#ApproxFunBase.canonicalspace","page":"Library","title":"ApproxFunBase.canonicalspace","text":"canonicalspace(s::Space)\n\nReturn a space that is used as a default to implement missing functionality, e.g., evaluation. Implement a Conversion operator or override coefficients to support this.\n\nExamples\n\njulia> ApproxFunBase.canonicalspace(NormalizedChebyshev())\nChebyshev()\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"itransform","category":"page"},{"location":"library/#ApproxFunBase.itransform","page":"Library","title":"ApproxFunBase.itransform","text":"itransform(s::Space,coefficients::AbstractVector)\n\nTransform coefficients back to values.  Defaults to using canonicalspace as in transform.\n\nExamples\n\njulia> F = Fun(x->x^2, Chebyshev())\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> itransform(Chebyshev(), coefficients(F)) ≈ values(F)\ntrue\n\njulia> itransform(Chebyshev(), [0.5, 0, 0.5])\n3-element Vector{Float64}:\n 0.75\n 0.0\n 0.75\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"transform","category":"page"},{"location":"library/#ApproxFunBase.transform","page":"Library","title":"ApproxFunBase.transform","text":"transform(s::Space, vals)\n\nTransform values on the grid specified by points(s,length(vals)) to coefficients in the space s. Defaults to coefficients(transform(canonicalspace(space),values),canonicalspace(space),space)\n\nExamples\n\njulia> F = Fun(x -> x^2, Chebyshev());\n\njulia> coefficients(F)\n3-element Vector{Float64}:\n 0.5\n 0.0\n 0.5\n\njulia> transform(Chebyshev(), values(F)) ≈ coefficients(F)\ntrue\n\njulia> v = map(F, points(Chebyshev(), 4)); # custom grid\n\njulia> transform(Chebyshev(), v)\n4-element Vector{Float64}:\n 0.5\n 0.0\n 0.5\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"evaluate","category":"page"},{"location":"library/#ApproxFunBase.evaluate","page":"Library","title":"ApproxFunBase.evaluate","text":"evaluate(coefficients::AbstractVector, sp::Space, x)\n\nEvaluate the expansion at a point x that lies in domain(sp). If x is not in the domain, the returned value will depend on the space, and should not be relied upon. See extrapolate to evaluate a function at a value outside the domain.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"ApproxFun.dimension(::Space)","category":"page"},{"location":"library/#DomainSets.dimension-Tuple{Space}","page":"Library","title":"DomainSets.dimension","text":"dimension(s::Space)\n\nReturn the dimension of s, which is the maximum number of coefficients.\n\n\n\n\n\n","category":"method"},{"location":"library/#Inbuilt-spaces","page":"Library","title":"Inbuilt spaces","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"SequenceSpace","category":"page"},{"location":"library/#ApproxFunBase.SequenceSpace","page":"Library","title":"ApproxFunBase.SequenceSpace","text":"SequenceSpace\n\nThe space of all sequences, i.e., infinite vectors. Also denoted ℓ⁰.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ConstantSpace","category":"page"},{"location":"library/#ApproxFunBase.ConstantSpace","page":"Library","title":"ApproxFunBase.ConstantSpace","text":"ConstantSpace\n\nThe 1-dimensional scalar space.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Chebyshev","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Chebyshev","page":"Library","title":"ApproxFunOrthogonalPolynomials.Chebyshev","text":"Chebyshev() is the space spanned by the Chebyshev polynomials\n\n    T_0(x),T_1(x),T_2(x),…\n\nwhere T_k(x) = cos(k*acos(x)).  This is the default space as there exists a fast transform and general smooth functions on [-1,1] can be easily resolved.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Hermite","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Hermite","page":"Library","title":"ApproxFunOrthogonalPolynomials.Hermite","text":"Hermite(L) represents H_k(sqrt(L) * x) where H_k are Hermite polynomials. Hermite() is equivalent to Hermite(1.0).\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Jacobi","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Jacobi","page":"Library","title":"ApproxFunOrthogonalPolynomials.Jacobi","text":"Jacobi(b,a) represents the space spanned by Jacobi polynomials P_k^{(a,b)}, which are orthogonal with respect to the weight (1+x)^β*(1-x)^α\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Laguerre","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Laguerre","page":"Library","title":"ApproxFunOrthogonalPolynomials.Laguerre","text":"Laguerre(α) is a space spanned by generalized Laguerre polynomials Lₙᵅ(x) 's on (0, Inf), which satisfy the differential equations\n\n    xy'' + (α + 1 - x)y' + ny = 0\n\nLaguerre() is equivalent to Laguerre(0) by default.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Ultraspherical","category":"page"},{"location":"library/#ApproxFunOrthogonalPolynomials.Ultraspherical","page":"Library","title":"ApproxFunOrthogonalPolynomials.Ultraspherical","text":"Ultraspherical(λ) is the space spanned by the ultraspherical polynomials\n\n    C_0^{(λ)}(x),C_1^{(λ)}(x),C_2^{(λ)}(x),…\n\nNote that λ=1 this reduces to Chebyshev polynomials of the second kind: C_k^{(1)}(x) = U_k(x). For λ=1/2 this also reduces to Legendre polynomials: C_k^{(1/2)}(x) = P_k(x).\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Taylor","category":"page"},{"location":"library/#ApproxFunFourier.Taylor","page":"Library","title":"ApproxFunFourier.Taylor","text":"Taylor() is the space spanned by [1,z,z^2,...]. This is a type alias for Hardy{true}.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Hardy","category":"page"},{"location":"library/#ApproxFunFourier.Hardy","page":"Library","title":"ApproxFunFourier.Hardy","text":"Hardy{false}() is the space spanned by [1/z,1/z^2,...]. Hardy{true}() is the space spanned by [1,z,z^2,...].\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Fourier","category":"page"},{"location":"library/#ApproxFunFourier.Fourier","page":"Library","title":"ApproxFunFourier.Fourier","text":"Fourier()\n\nThe space spanned by the trigonemtric polynomials\n\n    1, sin(θ), cos(θ), sin(2θ), cos(2θ), …\n\nSee also Laurent.\n\n\n\nFourier(d::Domain)\n\nThe space spanned by the trigonemtric polynomials\n\n    1, sin(2pi/L*θ), cos(2pi/L*θ), sin(2pi/L*2θ), cos(2pi/L*2θ), …\n\nfor a domain with a period L.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Laurent","category":"page"},{"location":"library/#ApproxFunFourier.Laurent","page":"Library","title":"ApproxFunFourier.Laurent","text":"Laurent()\n\nThe space spanned by the complex exponentials\n\n    1,exp(-im*θ),exp(im*θ),exp(-2im*θ),…\n\nSee also Fourier.\n\n\n\nLaurent(d::Domain)\n\nThe space spanned by the complex exponentials\n\n    1, exp(-im * (2pi/L*θ)), exp(im * (2pi/L*θ)), exp(-2im * (2pi/L*θ)), …\n\nfor a domain with a period L.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"CosSpace","category":"page"},{"location":"library/#ApproxFunFourier.CosSpace","page":"Library","title":"ApproxFunFourier.CosSpace","text":"CosSpace()\n\nThe space spanned by [1, cos θ, cos 2θ, ...]\n\n\n\nCosSpace(d::Domain)\n\nThe space spanned by [1,cos(2pi/L*θ), cos(2pi/L*2θ), ...] for a domain with a period L\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"SinSpace","category":"page"},{"location":"library/#ApproxFunFourier.SinSpace","page":"Library","title":"ApproxFunFourier.SinSpace","text":"SinSpace()\n\nThe space spanned by [sin θ, sin 2θ, ...]\n\n\n\nSinSpace(d::Domain)\n\nThe space spanned by [1, sin(2pi/L*θ), sin(2pi/L*2θ), ...] for a domain with a period L\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"JacobiWeight","category":"page"},{"location":"library/#ApproxFunSingularities.JacobiWeight","page":"Library","title":"ApproxFunSingularities.JacobiWeight","text":"JacobiWeight(β,α,s::Space)\n\nweights a space s by a Jacobi weight, which on -1..1 is (1+x)^β*(1-x)^α. For other domains, the weight is inferred by mapping to -1..1.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ApproxFun.LogWeight","category":"page"},{"location":"library/#ApproxFunSingularities.LogWeight","page":"Library","title":"ApproxFunSingularities.LogWeight","text":"LogWeight(β,α,s::Space)\n\nrepresents a function on -1..1 weighted by log((1+x)^β*(1-x)^α). For other domains, the weight is inferred by mapping to -1..1.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ApproxFun.ArraySpace","category":"page"},{"location":"library/#ApproxFunBase.ArraySpace","page":"Library","title":"ApproxFunBase.ArraySpace","text":"ArraySpace(s::Space,dims...)\n\nis used to represent array-valued expansions in a space s.  The coefficients are of each entry are interlaced.\n\nFor example,\n\nf = Fun(x->[exp(x),sin(x)],-1..1)\nspace(f) == ArraySpace(Chebyshev(),2)\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"TensorSpace","category":"page"},{"location":"library/#ApproxFunBase.TensorSpace","page":"Library","title":"ApproxFunBase.TensorSpace","text":"TensorSpace(a::Space,b::Space)\n\nrepresents a tensor product of two 1D spaces a and b. The coefficients are interlaced in lexigraphical order.\n\nFor example, consider\n\nFourier()*Chebyshev()  # returns TensorSpace(Fourier(),Chebyshev())\n\nThis represents functions on [-π,π) x [-1,1], using the Fourier basis for the first argument and Chebyshev basis for the second argument, that is, φ_k(x)T_j(y), where\n\nφ_0(x) = 1,\nφ_1(x) = sin x,\nφ_2(x) = cos x,\nφ_3(x) = sin 2x,\nφ_4(x) = cos 2x\n…\n\nBy Choosing (k,j) appropriately, we obtain a single basis:\n\nφ_0(x)T_0(y) (= 1),\nφ_0(x)T_1(y) (= y),\nφ_1(x)T_0(y) (= sin x),\nφ_0(x)T_2(y), …\n\n\n\n\n\n","category":"type"},{"location":"library/#Constructing-a-Fun","page":"Library","title":"Constructing a Fun","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Fun","category":"page"},{"location":"library/#ApproxFunBase.Fun","page":"Library","title":"ApproxFunBase.Fun","text":"Fun(s::Space, coefficients::AbstractVector)\n\nReturn a Fun with the specified coefficients in the space s\n\nExamples\n\njulia> f = Fun(Fourier(), [1,1]);\n\njulia> f(0.1) == 1 + sin(0.1)\ntrue\n\njulia> f = Fun(Chebyshev(), [1,1]);\n\njulia> f(0.1) == 1 + 0.1\ntrue\n\n\n\n\n\nFun()\n\nReturn Fun(identity, Chebyshev()), which represents the identity function in -1..1.\n\nExamples\n\njulia> f = Fun(Chebyshev())\nFun(Chebyshev(), [0.0, 1.0])\n\njulia> f(0.1)\n0.1\n\n\n\n\n\nFun(s::Space)\n\nReturn Fun(identity, s)\n\nExamples\n\njulia> x = Fun(Chebyshev())\nFun(Chebyshev(), [0.0, 1.0])\n\njulia> x(0.1)\n0.1\n\n\n\n\n\nFun(f, d::Domain)\n\nReturn Fun(f, Space(d)), that is, it uses the default space for the specified domain.\n\nExamples\n\njulia> f = Fun(x->x^2, 0..1);\n\njulia> f(0.1) ≈ (0.1)^2\ntrue\n\n\n\n\n\nFun(f, s::Space)\n\nReturn a Fun representing the function, number, or vector f in the space s.  If f is vector-valued, it Return a vector-valued analogue of s.\n\nExamples\n\njulia> f = Fun(x->x^2, Chebyshev())\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> f(0.1) == (0.1)^2\ntrue\n\n\n\n\n\nFun(f)\n\nReturn Fun(f, space) by choosing an appropriate space for the function. For univariate functions, space is chosen to be Chebyshev(), whereas for multivariate functions, it is a tensor product of Chebyshev() spaces.\n\nExamples\n\njulia> f = Fun(x -> x^2)\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> f(0.1) == (0.1)^2\ntrue\n\njulia> f = Fun((x,y) -> x + y);\n\njulia> f(0.1, 0.2) ≈ 0.3\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ones(::Space)","category":"page"},{"location":"library/#Base.ones-Tuple{Space}","page":"Library","title":"Base.ones","text":"ones(d::Space)\n\nReturn the Fun that represents the function one on the specified space.\n\nExamples\n\njulia> ones(Chebyshev())\nFun(Chebyshev(), [1.0])\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"zeros(::Space)","category":"page"},{"location":"library/#Base.zeros-Tuple{Space}","page":"Library","title":"Base.zeros","text":"zeros(d::Space)\n\nReturn the Fun that represents the function one on the specified space.\n\nExamples\n\njulia> zeros(Chebyshev())\nFun(Chebyshev(), [0.0])\n\n\n\n\n\n","category":"method"},{"location":"library/#Accessing-information-about-a-Fun","page":"Library","title":"Accessing information about a Fun","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"domain","category":"page"},{"location":"library/#ApproxFunBase.domain","page":"Library","title":"ApproxFunBase.domain","text":"domain(f::Fun)\n\nReturn the domain that f is defined on.\n\nExamples\n\njulia> f = Fun(x->x^2);\n\njulia> domain(f) == ChebyshevInterval()\ntrue\n\njulia> f = Fun(x->x^2, 0..1);\n\njulia> domain(f) == 0..1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"coefficients","category":"page"},{"location":"library/#ApproxFunBase.coefficients","page":"Library","title":"ApproxFunBase.coefficients","text":"coefficients(cfs::AbstractVector, fromspace::Space, tospace::Space) -> Vector\n\nConvert coefficients in fromspace to coefficients in tospace\n\nExamples\n\njulia> f = Fun(x->(3x^2-1)/2);\n\njulia> coefficients(f, Chebyshev(), Legendre()) ≈ [0,0,1]\ntrue\n\njulia> g = Fun(x->(3x^2-1)/2, Legendre());\n\njulia> coefficients(f, Chebyshev(), Legendre()) ≈ coefficients(g)\ntrue\n\n\n\n\n\ncoefficients(f::Fun, s::Space) -> Vector\n\nReturn the coefficients of f in the space s, which may not be the same as space(f).\n\nExamples\n\njulia> f = Fun(x->(3x^2-1)/2);\n\njulia> coefficients(f, Legendre()) ≈ [0, 0, 1]\ntrue\n\n\n\n\n\ncoefficients(f::Fun) -> Vector\n\nReturn the coefficients of f, corresponding to the space space(f).\n\nExamples\n\njulia> f = Fun(x->x^2)\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> coefficients(f)\n3-element Vector{Float64}:\n 0.5\n 0.0\n 0.5\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"extrapolate","category":"page"},{"location":"library/#ApproxFunBase.extrapolate","page":"Library","title":"ApproxFunBase.extrapolate","text":"extrapolate(f::Fun,x)\n\nReturn an extrapolation of f from its domain to x.\n\nExamples\n\njulia> f = Fun(x->x^2)\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> extrapolate(f, 2) # 2 lies outside the domain -1..1\n4.0\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"ncoefficients","category":"page"},{"location":"library/#ApproxFunBase.ncoefficients","page":"Library","title":"ApproxFunBase.ncoefficients","text":"ncoefficients(f::Fun) -> Integer\n\nReturn the number of coefficients of a fun\n\nExamples\n\njulia> f = Fun(x->x^2)\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> ncoefficients(f)\n3\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"points","category":"page"},{"location":"library/#ApproxFunBase.points","page":"Library","title":"ApproxFunBase.points","text":"points(s::Space,n::Integer)\n\nReturn a grid of approximately n points, for which a transform exists from values at the grid to coefficients in the space s.\n\nExamples\n\njulia> chebypts(n) = [cos((2i+1)pi/2n) for i in 0:n-1];\n\njulia> points(Chebyshev(), 4) ≈ chebypts(4)\ntrue\n\n\n\n\n\npoints(f::Fun)\n\nReturn a grid of points that f can be transformed into values and back.\n\nExamples\n\njulia> f = Fun(x->x^2);\n\njulia> chebypts(n) = [cos((2i+1)pi/2n) for i in 0:n-1];\n\njulia> points(f) ≈ chebypts(ncoefficients(f))\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"space","category":"page"},{"location":"library/#ApproxFunBase.space","page":"Library","title":"ApproxFunBase.space","text":"space(f::Fun)\n\nReturn the space of f.\n\nExamples\n\njulia> f = Fun(x->x^2)\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> space(f)\nChebyshev()\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"values(::Fun)","category":"page"},{"location":"library/#Base.values-Tuple{Fun}","page":"Library","title":"Base.values","text":"values(iterator)\n\nFor an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its \"values\".\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> values(d)\nValueIterator for a Dict{String, Int64} with 2 entries. Values:\n  2\n  1\n\njulia> values([2])\n1-element Vector{Int64}:\n 2\n\n\n\n\n\nvalues(f::Fun)\n\nReturn f evaluated at points(f).\n\nExamples\n\njulia> f = Fun(x->x^2)\nFun(Chebyshev(), [0.5, 0.0, 0.5])\n\njulia> values(f)\n3-element Vector{Float64}:\n 0.75\n 0.0\n 0.75\n\njulia> map(x->x^2, points(f)) ≈ values(f)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"stride(::Fun)","category":"page"},{"location":"library/#Base.stride-Tuple{Fun}","page":"Library","title":"Base.stride","text":"stride(f::Fun)\n\nReturn the stride of the coefficients, checked numerically\n\n\n\n\n\n","category":"method"},{"location":"library/#Modify-a-Fun","page":"Library","title":"Modify a Fun","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"reverseorientation","category":"page"},{"location":"library/#ApproxFunBase.reverseorientation","page":"Library","title":"ApproxFunBase.reverseorientation","text":"reverseorientation(f::Fun)\n\nReturn f on a reversed orientated contour.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"ApproxFun.setdomain","category":"page"},{"location":"library/#ApproxFunBase.setdomain","page":"Library","title":"ApproxFunBase.setdomain","text":"setdomain(f::Fun, d::Domain)\n\nReturn f projected onto domain.\n\nnote: Note\nThe new function may differ from the original one, as the coefficients are left unchanged.\n\nExamples\n\njulia> f = Fun(x->x^2);\n\njulia> domain(f) == ChebyshevInterval()\ntrue\n\njulia> g = setdomain(f, 0..1);\n\njulia> domain(g) == 0..1\ntrue\n\njulia> coefficients(f) == coefficients(g)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"chop(::Fun, ::Any)","category":"page"},{"location":"library/#Base.chop-Tuple{Fun, Any}","page":"Library","title":"Base.chop","text":"chop(f::Fun[, tol = 10eps()]) -> Fun\n\nReduce the number of coefficients by dropping the tail that is below the specified tolerance.\n\nExamples\n\njulia> f = Fun(Chebyshev(), [1,2,3,0,0,0])\nFun(Chebyshev(), [1, 2, 3, 0, 0, 0])\n\njulia> chop(f)\nFun(Chebyshev(), [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"library/#Bivariate-Fun","page":"Library","title":"Bivariate Fun","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"LowRankFun","category":"page"},{"location":"library/#ApproxFunBase.LowRankFun","page":"Library","title":"ApproxFunBase.LowRankFun","text":"LowRankFun(f, space::TensorSpace)\n\nReturn an approximation to a bivariate function in a low-rank form\n\nf(xy) = sum_i sigma_i phi_i(x) psi_i(y)\n\nwhere sigma_i represent the highest singular values, and phi_i(x) and psi_i(y) are orthogonal bases. The summation is truncated after an acceptable tolerance is reached.\n\nExamples\n\njulia> f = (x,y) -> x^2 * y^3;\n\njulia> L = LowRankFun(f, Chebyshev() ⊗ Chebyshev());\n\njulia> L(0.1, 0.2) ≈ f(0.1, 0.2)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ProductFun","category":"page"},{"location":"library/#ApproxFunBase.ProductFun","page":"Library","title":"ApproxFunBase.ProductFun","text":"ProductFun(coeffs::AbstractMatrix{T}, sp::AbstractProductSpace; [tol=100eps(T)], [chopping=false]) where {T<:Number}\n\nRepresent a bivariate function f in terms of the coefficient matrix coeffs, where the coefficients are obtained using a bivariate transform of the function f in the basis sp.\n\nExamples\n\njulia> P = ProductFun([0 0; 0 1], Chebyshev() ⊗ Chebyshev()) # corresponds to (x,y) -> x*y\nProductFun on Chebyshev() ⊗ Chebyshev()\n\njulia> P(0.1, 0.2) ≈ 0.1 * 0.2\ntrue\n\n\n\n\n\nProductFun(M::AbstractVector{<:Fun{<:UnivariateSpace}}, sp::UnivariateSpace)\n\nRepresent a bivariate function f(x,y) in terms of the univariate coefficient functions from M. The function f may be reconstructed as\n\nfleft(xyright)=sum_iM_ileft(xright)b_ileft(yright)\n\nwhere b_ileft(yright) represents the i-th basis function for the space sp.\n\nExamples\n\njulia> P = ProductFun([zeros(Chebyshev()), Fun(Chebyshev())], Chebyshev()); # corresponds to (x,y)->x*y\n\njulia> P(0.1, 0.2) ≈ 0.1 * 0.2\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/#Operators","page":"Library","title":"Operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Operator","category":"page"},{"location":"library/#ApproxFunBase.Operator","page":"Library","title":"ApproxFunBase.Operator","text":"Operator{T}\n\nAbstract type to represent linear operators between spaces.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BandedMatrices.bandwidths(::Operator)","category":"page"},{"location":"library/#BandedMatrices.bandwidths-Tuple{Operator}","page":"Library","title":"BandedMatrices.bandwidths","text":"bandwidths(op::Operator)\n\nReturn the bandwidth of op in the form (l,u), where l ≥ 0 represents the number of subdiagonals and u ≥ 0 represents the number of superdiagonals.\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"domainspace","category":"page"},{"location":"library/#ApproxFunBase.domainspace","page":"Library","title":"ApproxFunBase.domainspace","text":"domainspace(op::Operator)\n\nReturn the domain space of op.  That is, op*f will first convert f to a Fun in the space domainspace(op) before applying the operator.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"rangespace","category":"page"},{"location":"library/#ApproxFunBase.rangespace","page":"Library","title":"ApproxFunBase.rangespace","text":"rangespace(op::Operator)\n\nReturn the range space of op.  That is, op*f will return a Fun in the space rangespace(op), provided f can be converted to a Fun in domainspace(op).\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getindex(::Operator,::Any,::Any)","category":"page"},{"location":"library/#Base.getindex-Tuple{Operator, Any, Any}","page":"Library","title":"Base.getindex","text":"(op::Operator)[k,j]\n\nReturn the kth coefficient of op*Fun([zeros(j-1);1],domainspace(op)).\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"getindex(::Operator,::Fun)","category":"page"},{"location":"library/#Base.getindex-Tuple{Operator, Fun}","page":"Library","title":"Base.getindex","text":"(op::Operator)[f::Fun]\n\nConstruct the operator op * Multiplication(f), that is, it multiplies on the right by f first.  Note that op * f is different: it applies op to f.\n\nExamples\n\njulia> x = Fun()\nFun(Chebyshev(), [0.0, 1.0])\n\njulia> D = Derivative()\nConcreteDerivative : ApproxFunBase.UnsetSpace() → ApproxFunBase.UnsetSpace()\n\njulia> Dx = D[x] # construct the operator y -> d/dx * (x * y)\nTimesOperator : ApproxFunBase.UnsetSpace() → ApproxFunBase.UnsetSpace()\n\njulia> twox = Dx * x # Evaluate d/dx * (x * x)\nFun(Ultraspherical(1), [0.0, 1.0])\n\njulia> twox(0.1) ≈ 2 * 0.1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"\\(::Operator,::Any)","category":"page"},{"location":"library/#Base.:\\-Tuple{Operator, Any}","page":"Library","title":"Base.:\\","text":"\\(A::Operator,b;tolerance=tol,maxlength=n)\n\nsolves a linear equation, usually differential equation, where A is an operator or array of operators and b is a Fun or array of funs.  The result u will approximately satisfy A*u = b.\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"qr(::Operator)","category":"page"},{"location":"library/#LinearAlgebra.qr-Tuple{Operator}","page":"Library","title":"LinearAlgebra.qr","text":"qr(A::Operator)\n\nreturns a cached QR factorization of the Operator A.  The result QR enables solving of linear equations: if u=QR\b, then u approximately satisfies A*u = b.\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"cache(::Operator)","category":"page"},{"location":"library/#LazyArrays.cache-Tuple{Operator}","page":"Library","title":"LazyArrays.cache","text":"cache(op::Operator)\n\nCaches the entries of an operator, to speed up multiplying a Fun by the operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#Inbuilt-operators","page":"Library","title":"Inbuilt operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Conversion","category":"page"},{"location":"library/#ApproxFunBase.Conversion","page":"Library","title":"ApproxFunBase.Conversion","text":"Conversion(fromspace::Space, tospace::Space)\n\nRepresent a conversion operator between fromspace and tospace, when available.\n\nSee also PartialInverseOperator that might be able to represent the inverse, even if this isn't banded.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Derivative","category":"page"},{"location":"library/#ApproxFunBase.Derivative","page":"Library","title":"ApproxFunBase.Derivative","text":"Derivative(sp::Space, k::Int)\n\nReturn the k-th derivative operator on the space sp.\n\nExamples\n\njulia> Derivative(Chebyshev(), 2) * Fun(x->x^4) ≈ Fun(x->12x^2)\ntrue\n\n\n\n\n\nDerivative(sp::Space, k::AbstractVector{Int})\n\nReturn a partial derivative operator on a multivariate space. For example,\n\nDx = Derivative(Chebyshev()^2,[1,0]) # ∂/∂x\nDy = Derivative(Chebyshev()^2,[0,1]) # ∂/∂y\n\ntip: Tip\nUsing a static vector as the second argument would help with type-stability.\n\nExamples\n\njulia> ∂y = Derivative(Chebyshev()^2, [0,1]);\n\njulia> ∂y * Fun((x,y)->x^2 + y^2) ≈ Fun((x,y)->2y)\ntrue\n\n\n\n\n\nDerivative(sp::Space)\n\nReturn the first derivative operator, equivalent to Derivative(sp,1).\n\nExamples\n\njulia> Derivative(Chebyshev()) * Fun(x->x^2) ≈ Fun(x->2x)\ntrue\n\n\n\n\n\nDerivative(k)\n\nReturn the k-th derivative, acting on an unset space. Spaces will be inferred when applying or manipulating the operator. If k is an Int, this returns a derivative in an univariate space. If k is an AbstractVector{Int}, this returns a partial derivative in a multivariate space.\n\nExamples\n\njulia> Derivative(1) * Fun(x->x^2) ≈ Fun(x->2x)\ntrue\n\njulia> Derivative([0,1]) * Fun((x,y)->x^2+y^2) ≈ Fun((x,y)->2y)\ntrue\n\n\n\n\n\nDerivative()\n\nReturn the first derivative on an unset space. Spaces will be inferred when applying or manipulating the operator.\n\nExamples\n\njulia> Derivative() * Fun(x->x^2) ≈ Fun(x->2x)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Dirichlet","category":"page"},{"location":"library/#ApproxFunBase.Dirichlet","page":"Library","title":"ApproxFunBase.Dirichlet","text":"Dirichlet(sp,k) is the operator associated with restricting the k-th derivative on the boundary for the space sp.\n\n\n\n\n\nDirichlet(sp) is the operator associated with restricting the  the boundary for the space sp.\n\n\n\n\n\nDirichlet() is the operator associated with restricting on the  the boundary.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Evaluation","category":"page"},{"location":"library/#ApproxFunBase.Evaluation","page":"Library","title":"ApproxFunBase.Evaluation","text":"Evaluation(sp,x,k) is the functional associated with evaluating the k-th derivative at a point x for the space sp.\n\n\n\n\n\nEvaluation(sp,x) is the functional associated with evaluating at a point x for the space sp.\n\n\n\n\n\nEvaluation(x) is the functional associated with evaluating at a point x.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Integral","category":"page"},{"location":"library/#ApproxFunBase.Integral","page":"Library","title":"ApproxFunBase.Integral","text":"Integral(sp::Space, k::Int)\n\nReturn the k-th integral operator on sp. There is no guarantee on normalization.\n\n\n\n\n\nIntegral(sp::Space)\n\nReturn the first integral operator, equivalent to Integral(sp,1).\n\n\n\n\n\nIntegral(k::Int)\n\nReturn the k-th integral operator, acting on an unset space. Spaces will be inferred when applying or manipulating the operator.\n\n\n\n\n\nIntergral()\n\nReturn the first integral operator on an unset space. Spaces will be inferred when applying or manipulating the operator.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Laplacian","category":"page"},{"location":"library/#ApproxFunBase.Laplacian","page":"Library","title":"ApproxFunBase.Laplacian","text":"Laplacian(sp::Space)\n\nReturn the laplacian operator on space sp.\n\n\n\n\n\nLaplacian()\n\nReturn the laplacian operator on an unset space. Spaces will be inferred when applying or manipulating the operator.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Multiplication","category":"page"},{"location":"library/#ApproxFunBase.Multiplication","page":"Library","title":"ApproxFunBase.Multiplication","text":"Multiplication(f::Fun,sp::Space) is the operator representing multiplication by f on functions in the space sp.\n\n\n\n\n\nMultiplication(f::Fun) is the operator representing multiplication by f on an unset space of functions.  Spaces will be inferred when applying or manipulating the operator.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Neumann","category":"page"},{"location":"library/#ApproxFunBase.Neumann","page":"Library","title":"ApproxFunBase.Neumann","text":"Neumann(sp) is the operator associated with restricting the normal derivative on the boundary for the space sp. At the moment it is implemented as Dirichlet(sp,1).\n\n\n\n\n\nNeumann() is the operator associated with restricting the normal derivative on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"PartialInverseOperator","category":"page"},{"location":"library/#ApproxFunBase.PartialInverseOperator","page":"Library","title":"ApproxFunBase.PartialInverseOperator","text":"PartialInverseOperator(O::Operator, bandwidths = (0, Infinities.ℵ₀))\n\nReturn an approximate estimate for inv(O), such that PartialInverseOperator(O) * O is banded, and is approximately I up to a bandwidth that is one less than the sum of the bandwidths of O and PartialInverseOperator(O).\n\nnote: Note\nOnly upper-triangular operators are supported as of now.\n\nExamples\n\njulia> C = Conversion(Chebyshev(), Ultraspherical(1));\n\njulia> P = PartialInverseOperator(C); # default bandwidth\n\njulia> P * C\nTimesOperator : Chebyshev() → Chebyshev()\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ⋯\n  ⋅   1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ⋱\n  ⋅    ⋅   1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  ⋱\n  ⋅    ⋅    ⋅   1.0  0.0  0.0  0.0  0.0  0.0  0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅   1.0  0.0  0.0  0.0  0.0  0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0  0.0  0.0  0.0  0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0  0.0  0.0  0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0  0.0  0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0  0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0  ⋱\n  ⋮    ⋱    ⋱    ⋱    ⋱    ⋱    ⋱    ⋱    ⋱    ⋱   ⋱\n\njulia> P = PartialInverseOperator(C, (0, 4)); # specify an upper bandwidth\n\njulia> P * C\nTimesOperator : Chebyshev() → Chebyshev()\n 1.0  0.0  0.0  0.0  0.0  0.0  -0.5    ⋅     ⋅     ⋅   ⋅\n  ⋅   1.0  0.0  0.0  0.0  0.0   0.0  -1.0    ⋅     ⋅   ⋅\n  ⋅    ⋅   1.0  0.0  0.0  0.0   0.0   0.0  -1.0    ⋅   ⋅\n  ⋅    ⋅    ⋅   1.0  0.0  0.0   0.0   0.0   0.0  -1.0  ⋅\n  ⋅    ⋅    ⋅    ⋅   1.0  0.0   0.0   0.0   0.0   0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   0.0   0.0   0.0   0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    1.0   0.0   0.0   0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅     ⋅    1.0   0.0   0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅     ⋅     ⋅    1.0   0.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅     ⋅     ⋅     ⋅    1.0  ⋱\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅     ⋅     ⋅     ⋅     ⋅   ⋱\n\n\n\n\n\n","category":"type"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"EditURL = \"../../../examples/Sampling.jl\"","category":"page"},{"location":"generated/Sampling/#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"Random number sampling using Olver & Townsend 2013. The following code samples 10,000 from a PDF given as the absolute value of the sine function on [-5,5]:","category":"page"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"using ApproxFun\n\nf = abs(Fun(sin,-5..5))\nx = ApproxFun.sample(f, 10000);\nnothing #hide","category":"page"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"We plot a histogram of the samples","category":"page"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"import Plots\nPlots.histogram(x; bins=100, normalize = :pdf,\n    title = \"Histogram\", xlabel=\"value\", ylabel=\"frequency\",\n    xlim = (-5,5), ylim=(0, Inf), legend = false)\nPlots.plot!(f/sum(f), linewidth=3)","category":"page"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"","category":"page"},{"location":"generated/Sampling/","page":"Sampling","title":"Sampling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"DocTestSetup  = quote\n    using ApproxFun, LinearAlgebra\nend","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"using ApproxFun","category":"page"},{"location":"usage/operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Linear operators between two spaces in ApproxFun are represented by subtypes of Operator.  Every operator has a domainspace and rangespace.  That is, if a Fun f has the space domainspace(op), thenop * f is a Fun with space rangespace(op).","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Note that the size of an operator is specified by the dimension of the domain and range space.","category":"page"},{"location":"usage/operators/#Calculus-operators","page":"Operators","title":"Calculus operators","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Differential and integral operators are perhaps the most useful type of operators in mathematics.  Consider the derivative operator on CosSpace:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> D = Derivative(CosSpace());\n\njulia> f = Fun(θ->cos(cos(θ)), CosSpace());\n\njulia> fp = D * f;\n\njulia> fp(0.1) ≈ f'(0.1) ≈ sin(cos(0.1))*sin(0.1)\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Here, we specified the domain space for the derivative operator, and it automatically determined the range space:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> rangespace(D) == space(fp) == SinSpace()\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Operators can be identified with infinite-dimensional matrices, whose entries are given by the canonical bases in the domain and range space.  In this case, the relevant formula is","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"mathopD coskθ = -k sinkθ","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"That is, the (k,k+1)th entry is as follows:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> k,j = 5,6;\n\njulia> ej = Fun(domainspace(D), [zeros(j-1);1]);\n\njulia> D[k,j] ≈ coefficient(D * ej, k) ≈ -k\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"The Chebyshev space has the property that its derivatives are given by ultraspherical spaces:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Derivative(Chebyshev())","category":"page"},{"location":"usage/operators/#Functionals","page":"Operators","title":"Functionals","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"A particularly useful class of operators are functionals, which map from functions to scalar numbers.  These are represented by operators of size 1 × ∞: that is, infinite-dimensional analogues of row vectors.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"As an example, the evaluation functional f(0) on CosSpace has the form:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> B = Evaluation(CosSpace(), 0);\n\njulia> B * f ≈ f(0)\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"As can be seen from the output, rangespace(B) is a ConstantSpace(Point(0)), a one-dimensional space used to represent scalars whose domain is a single point, 0.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Closely related to functionals are operators with finite-dimensional range.  For example, the Dirichlet operator represents the restriction of a space to its boundary.  In the case, of Chebyshev(), this amounts to evaluation at the endpoints ±1:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> B = Dirichlet(Chebyshev());\n\njulia> size(B)\n(2, ℵ₀)\n\njulia> B * Fun(exp) ≈ Fun([exp(-1), exp(1)])\ntrue","category":"page"},{"location":"usage/operators/#Multiplication","page":"Operators","title":"Multiplication","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"A Multiplication operator sends a Fun to a Fun in the corresponding space by multiplying a given function. The Multiplication operators are presented in matrix form in ApproxFun.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> x = Fun();\n\njulia> M = Multiplication(1 + 2x + x^2, Chebyshev());\n\njulia> coefficients(M * x) == coefficients((1 + 2x + x^2) * x) == M[1:4,1:2] * coefficients(x)\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"It is possible for domain space and range space to be different under Mulitplication.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> cosθ = Fun(cos, CosSpace());\n\njulia> sinθ = Fun(sin, SinSpace());\n\njulia> sin2θ = Fun(x->sin(2x), SinSpace());\n\njulia> cosθM = Multiplication(cosθ, SinSpace());\n\njulia> cosθM * 2sinθ ≈ sin2θ\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"If a function is given by the expansion","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"mathopf(θ) = sum_n=1^  f_n sinnθ","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Then the matrix above can be easily derived from","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"beginaligned\ncosθ mathopf(θ) = cosθ sum_n=1^ f_n sinnθ \n                          = sum_n=1^ f_n cosθ sinnθ \n                          = sum_n=1^ frac12 f_n left(sin(n-1)θ + sin(n+1)θright) \n                          = sum_n=1^ frac12 left(f_n-1 + f_n+1right) sinnθ\nendaligned","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"where f_0 = 0.","category":"page"},{"location":"usage/operators/#Algebraic-manipulation-of-operators","page":"Operators","title":"Algebraic manipulation of operators","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Operators can be algebraically manipulated, provided that the domain and range spaces are compatible, or can be made compatible.  As a simple example, we can add the second derivative of a Fourier space to the identity operator:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> D2 = Derivative(Fourier(),2);\n\njulia> (D2 + I) * Fun(x -> cos(2x), Fourier()) ≈ Fun(x -> -3cos(2x), Fourier())\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"When the domain and range space are not the same, the identity operator becomes a conversion operator.  That is, to represent D+I acting on the Chebyshev space, we would do the following:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> f = Fun(x->x^3, Chebyshev());\n\njulia> D = Derivative(Chebyshev());\n\njulia> (D + I) * f ≈ Fun(x->x^3 + 3x^2)\ntrue\n\njulia> C = Conversion(Chebyshev(), Ultraspherical(1));\n\njulia> (D + C) * f ≈ Fun(x->x^3 + 3x^2)\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"ApproxFun can automatically determine the spaces, so if one writes D + I it will translate it to D + C.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Now consider the Fredholm integral operator of the second kind:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"mathopL mathopu = mathopu + mathope^x int_-1^1 mathopu(x) mathopdx","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"We can construct this using","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> x = Fun();\n\njulia> Σ = DefiniteIntegral(Chebyshev());\n\njulia> L = I + exp(x)*Σ;\n\njulia> u = cos(10x^2);\n\njulia> (L * u)(0.1) ≈ u(0.1) + exp(0.1) * sum(u)\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Note that DefiniteIntegral is a functional, i.e., a 1 × ∞ operator.  when multiplied on the left by a function, it automatically constructs the operator mathrmL=mathope^x int_-1^1 mathopf(x) mathopdx via","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> x = Fun();\n\njulia> Σ = DefiniteIntegral();\n\njulia> M = Multiplication(exp(x));\n\njulia> L = M * Σ;\n\njulia> L * Fun(x->3x^2/2, Chebyshev()) ≈ Fun(exp, Chebyshev())\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"note: Note\nΣ * exp(x) applies the operator to a function.  To construct the operator that first multiplies by exp(x), use Σ[exp(x)].  This is equivalent to Σ * Multiplication(exp(x)).","category":"page"},{"location":"usage/operators/#Operators-and-space-promotion","page":"Operators","title":"Operators and space promotion","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"It is often more convenient to not specify a space explicitly, but rather infer it when the operator is used.  For example, we can construct Derivative(), which has the alias 𝒟 (typed as \\scrD<tab>), and represents the first derivative on any space:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"julia> f = Fun(cos, Chebyshev(0..1));\n\njulia> (𝒟 * f)(0.1) ≈ -sin(0.1)\ntrue\n\njulia> f = Fun(cos, Fourier());\n\njulia> (𝒟 * f)(0.1) ≈ -sin(0.1)\ntrue","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Behind the scenes, Derivative() is equivalent to Derivative(UnsetSpace(),1).  When multiplying a function f, the domain space is promoted before multiplying, that is, Derivative() * f is equivalent to Derivative(space(f)) * f.","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"This promotion of the domain space happens even when operators have spaces attached.  This facilitates the following construction:","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"D = Derivative(Chebyshev());\nD^2","category":"page"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"Note that rangespace(D) ≠ Chebyshev(), hence the operators are not compatible.  Therefore, it has thrown away its domain space, and thus this is equivalent to Derivative(rangespace(D))*D.","category":"page"},{"location":"usage/operators/#Concatenating-operators","page":"Operators","title":"Concatenating operators","text":"","category":"section"},{"location":"usage/operators/","page":"Operators","title":"Operators","text":"The concatenation functions vcat, hcat and hvcat are overriden for operators to represent the resulting combined operator, now with a rangespace or domainspace that is an ArraySpace.","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"DocTestSetup  = quote\n    using ApproxFun, LinearAlgebra\nend","category":"page"},{"location":"usage/constructors/#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"Funs in ApproxFun are instances of Julia types with one field to store coefficients and another to describe the function space. Similarly, each function space has one field describing its domain, or another function space. Let's explore:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"julia> x = Fun(identity,-1..1);\n\njulia> f = exp(x);\n\njulia> space(f) == Chebyshev(-1..1)\ntrue","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"In this example, f is a Fun that corresponds to a Chebyshev interpolant to exp(x), and evaluating f(x) will generate a close approximation to exp(x). In this case, the space is automatically inferred from the domain.","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"Funs may also incorporate singularities at the edges of the domain. In such cases, if the variable is in a polynomial space, the resulting space is a JacobiWeight, which factors out the singularity and interpolates the residual analytical component. Perhaps this is best illustrated through an example:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"julia> g = f/sqrt(1-x^2);\n\njulia> space(g) == JacobiWeight(-0.5, -0.5, Chebyshev(-1..1))\ntrue","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"The function g in this case is expanded the basis (1-x^2)^12T_n(x), where T_n(x) are Chebyshev polynomials. This is equivalent to expanding the function f in a Chebyshev basis.","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"The absolute value is another case where the space of the output is inferred from the operation:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"julia> f = Fun(x->cospi(5x), -1..1);\n\njulia> g = abs(f);\n\njulia> space(g) isa ContinuousSpace # Piecewise continous functions\ntrue\n\njulia> domain(g) isa PiecewiseSegment # Segments interspersed by the roots of f\ntrue","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"We may check that the domain corresponds to segments separated by the roots of f, and the space is that of continuous functions over the piecewise domain:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"julia> p = [-1; roots(f); 1];\n\njulia> segments = [Segment(x,y) for (x,y) in zip(p[1:end-1], p[2:end])];\n\njulia> components(domain(g)) == segments\ntrue\n\njulia> space(g) == ContinuousSpace(PiecewiseSegment(reverse(segments)))\ntrue","category":"page"},{"location":"usage/constructors/#Convenience-constructors","page":"Constructors","title":"Convenience constructors","text":"","category":"section"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"The default space is Chebyshev, which can represent non-periodic functions on intervals.  Each Space type has a default domain: for Chebyshev this is -1..1, for Fourier and Laurent this is -π..π.  Thus the following are equivalent:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"Fun(exp,Chebyshev(Interval(-1,1)))\nFun(exp,Chebyshev(ChebyshevInterval()))\nFun(exp,Chebyshev(-1..1))\nFun(exp,Chebyshev())\nFun(exp,-1..1)\nFun(exp,ChebyshevInterval())\nFun(exp,Interval(-1,1))\nFun(exp)","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"If a function is not specified, then it is taken to be identity.  Thus we have the following equivalent constructions:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"x = Fun(identity, -1..1)\nx = Fun(-1..1)\nx = Fun(identity)\nx = Fun()","category":"page"},{"location":"usage/constructors/#Specifying-coefficients-explicitly","page":"Constructors","title":"Specifying coefficients explicitly","text":"","category":"section"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"It is sometimes necessary to specify coefficients explicitly.  This is possible via specifying the space followed by a vector of coefficients:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"julia> f = Fun(Taylor(), [1,2,3]);  # represents 1 + 2z + 3z^2\n\njulia> f(0.1) ≈ 1 + 2*0.1 + 3*0.1^2\ntrue","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"In higher dimensions, ApproxFun will sum products of the 1D basis functions. So if mathopT_i(x) is the ith basis function, then a 2D function can be approximated as the following:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"mathopf(xy) = sum_ij c_ij mathopT_i(x) mathopT_j(y)","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"The products will be ordered lexicographically by the degree of the polynomial, i.e., in the order","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"mathopT_0(x) mathopT_0(y) mathopT_0(x) mathopT_1(y) mathopT_1(x) mathopT_0(y) mathopT_0(x) mathopT_2(y) mathopT_1(x) mathopT_1(y) mathopT_2(x) mathopT_0(y) ","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"For example, if we are in the two dimensional CosSpace space and we have coefficients c_1 c_2 c_3, then","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"mathopf(x y) = c_1 cos(0 x) cos(0 y) + c_2 cos(0 x) cos(1 y) + c_3 cos(1 x) cos(0 y)","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"This is illustrated in the following code:","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"julia> f = Fun(CosSpace()^2, [1,2,3]);\n\njulia> f(1,2) ≈ 1cos(0*1)*cos(0*2) + 2cos(0*1)*cos(1*2) + 3cos(1*1)*cos(0*2)\ntrue","category":"page"},{"location":"usage/constructors/#Using-ApproxFun-for-“manual”-interpolation","page":"Constructors","title":"Using ApproxFun for “manual” interpolation","text":"","category":"section"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"The ApproxFun package for Julia implements all of the necessary operations for Chebyshev interpolation and operations (like differentiation or integration) on Chebyshev interpolants.","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"Normally, you give it a function f and a domain d, and construct the Chebyshev interpolant by fc = Fun(f, d). The ApproxFun package figures out the necessary number of Chebyshev points (i.e., the polynomial order) required to interpolate f to nearly machine precision, so that subsequent operations on fc can be viewed as \"exact\".","category":"page"},{"location":"usage/constructors/","page":"Constructors","title":"Constructors","text":"However, in cases where the function to be interpolated is extremely expensive, and possibly even is evaluated by an external program, it is convenient to be able to decide on the desired Chebyshev order in advance, evaluate the function at those points \"manually\", and then construct the Chebyshev interpolant. An example showing how to do this is given in the ApproxFun FAQ.","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"using ApproxFun, Random","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#Approximating-functions","page":"Frequently Asked Questions","title":"Approximating functions","text":"","category":"section"},{"location":"faq/#How-do-I-interpolate-a-function-at-a-specified-grid?","page":"Frequently Asked Questions","title":"How do I interpolate a function at a specified grid?","text":"","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"In the case where the grid is specified by points(space,n), you can apply the default transform to data:","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"S = Chebyshev(1..2);\np = points(S,20);  # the default grid\nv = exp.(p);  # values at the default grid\nf = Fun(S,ApproxFun.transform(S,v));\nf(1.1)\nexp(1.1)","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"ApproxFun has no inbuilt support for interpolating functions at other sets of points, but this can be accomplished manually by evaluating the basis at the set of points and using \\:","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"S = Chebyshev(1..2);\nn = 50;\np = range(1,stop=2,length=n);  # a non-default grid\nv = exp.(p);  # values at the non-default grid\nV = Array{Float64}(undef,n,n);  # Create a Vandermonde matrix by evaluating the basis at the grid\nfor k = 1:n\n   V[:,k] = Fun(S,[zeros(k-1);1]).(p)\nend\nf = Fun(S,V\\v);\nf(1.1)\nexp(1.1)","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Note that an evenly spaced grid suffers from instability for large n.  The easiest way around this is to use least squares with more points than coefficients, instead of interpolation:","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"S = Chebyshev(1..2);\nn = 100; m = 50;\np = range(1,stop=2,length=n);  # a non-default grid\nv = exp.(p);  # values at the non-default grid\nV = Array{Float64}(undef,n,m);  # Create a Vandermonde matrix by evaluating the basis at the grid\nfor k = 1:m\n   V[:,k] = Fun(S,[zeros(k-1);1]).(p)\nend\nf = Fun(S,V\\v);\nf(1.1)\nexp(1.1)","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"We can use this same approach for multivariate functions:","category":"page"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"S = Chebyshev(0..1)^2;\nn = 1000; m = 50;\nRandom.seed!(0); x = rand(n); y = rand(n);\nv = exp.(x .* cos.(y));  # values at the non-default grid\nV = Array{Float64}(undef,n,m);  # Create a Vandermonde matrix by evaluating the basis at the grid\nfor k = 1:m\n   V[:,k] = Fun(S,[zeros(k-1);1]).(x,y)\nend\nf = Fun(S,V\\v);\nf(0.1,0.2)\nexp(0.1*cos(0.2))","category":"page"},{"location":"internals/multivariate/#Multivariate-functions","page":"Multivariate functions","title":"Multivariate functions","text":"","category":"section"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"Bivariate functions can also be represented in ApproxFun.  For example,","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"f=Fun((x,y)->exp(-x^2-y^2), ChebyshevInterval()^2)","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"constructs a function on the rectangle [-1,1]^2.  Just as in the 1D case, f.coefficients is a Vector of coefficients, and f.space is a Space that tells how to interpret the coefficients.","category":"page"},{"location":"internals/multivariate/#TensorSpace","page":"Multivariate functions","title":"TensorSpace","text":"","category":"section"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"In the example above, the resulting space is a TensorSpace.","category":"page"},{"location":"internals/multivariate/#AbstractProductSpace","page":"Multivariate functions","title":"AbstractProductSpace","text":"","category":"section"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"A TensorSpace is a subtype of AbstractProductSpace.  The purpose of AbstractProductSpaces beyond TensorSpace is that it is often convenient to use different bases in one-dimension depending on the order.  Thus we want to be able to represent functions in the basis φ_k^j(x)ζ_j(y): for example, we could have the basis","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"(1-x^2)^m2 mathrmP_k^(mm)(x) e^imy","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"(which is related to spherical harmonics), where mathrmP_k^(mm)(x) are Jacobi polynomials.","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"To handle this more general setting, an AbstractProductSpace implements ApproxFunBase.columnspace:  In the (1-x^2)^(m/2) P_k^{(m,m)}(x) e^{imy} example, we would have","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"columnspace(myproductspace,1)  ==  JacobiWeight(0,0,Legendre()),\ncolumnspace(myproductspace,2)  ==  JacobiWeight(0.5,0.5,Jacobi(1,1)),\ncolumnspace(myproductspace,k)  ==  JacobiWeight((k-1)/2,(k-1)/2,Jacobi(k-1,k-1))","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"The basis is then interlaced as in TensorSpace.","category":"page"},{"location":"internals/multivariate/#ProductFun","page":"Multivariate functions","title":"ProductFun","text":"","category":"section"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"A Fun is only one possible way to represent a bivariate function.  This mirrors linear algebra where a matrix can be represented in different formats depending on the usage Matrix or SparseMatrixCSC, for example.","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"Another format for representing bivariate functions in ApproxFun is a ProductFun:  for example, the previous function could also be represented by","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"f=ProductFun((x,y)->exp(-x^2-y^2),ChebyshevInterval()^2)","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"A ProductFun also has two fields: f.coefficients and f.space, where f.space must be an AbstractProductSpace.   Here, f.coefficients is a Vector{Fun{S,T}} that represents a list of functions in x, where","category":"page"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"space(f.coefficients[k]) == columnspace(f.space, k)","category":"page"},{"location":"internals/multivariate/#LowRankFun","page":"Multivariate functions","title":"LowRankFun","text":"","category":"section"},{"location":"internals/multivariate/","page":"Multivariate functions","title":"Multivariate functions","text":"LowRankFun represents a function as a sum of outer products of 1D Funs. This form tries to minimize the number of functions necessary by retaining the highest singular values of the function.","category":"page"},{"location":"usage/domains/#Domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"Domain is an abstract type whose subtypes represent oriented domains on which we wish to approximate functions.  Examples include Interval, Ray, Line and Arc.  Periodic domains include PeriodicSegment, PeriodicLine and Circle.","category":"page"},{"location":"usage/domains/#Relationship-with-spaces","page":"Domains","title":"Relationship with spaces","text":"","category":"section"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"Every domain d has a default space, constructed via Space(d).  For example, the default space for ChebyshevInterval() is Chebyshev(ChebyshevInterval()), which is efficient for representing smooth functions.  On the other hand, the default space for PeriodicSegment() is Fourier(PeriodicSegment()), which uses trigonometric polynomials to approximate periodic functions.  ","category":"page"},{"location":"usage/domains/#Manipulating-domains","page":"Domains","title":"Manipulating domains","text":"","category":"section"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"Domains can be manipulated to make more complicated domains.  For example, you can take the union of an interval and a circle","category":"page"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"ChebyshevInterval() ∪ Circle(3,0.5)  # equivalent to union(ChebyshevInterval(),Circle(3,0.5))","category":"page"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"and the following creates a rectangle [0,1]^2:","category":"page"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"rect=Interval(0,1)^2","category":"page"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"Some other set operations are partially implemented:","category":"page"},{"location":"usage/domains/","page":"Domains","title":"Domains","text":"Interval(0,2) ∩ ChebyshevInterval()  # returns Interval(0,1)","category":"page"},{"location":"internals/spaces/#Spaces","page":"Spaces","title":"Spaces","text":"","category":"section"},{"location":"internals/spaces/#UnsetSpace","page":"Spaces","title":"UnsetSpace","text":"","category":"section"},{"location":"internals/spaces/","page":"Spaces","title":"Spaces","text":"UnsetSpace is used to indicate that an operator has not had spaces specified. If the domain space of an operator is an UnsetSpace, so should the range space.","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"DocTestSetup  = quote\n    using ApproxFun, LinearAlgebra\nend","category":"page"},{"location":"usage/equations/#Linear-equations","page":"Linear Equations","title":"Linear equations","text":"","category":"section"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"Linear equations such as ordinary and partial differential equations, fractional differential equations and integral equations can be solved using ApproxFun.  This is accomplished using A\\b where A is an Operator and b is a Fun.  As a simple example, consider the equation","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"mathopu(θ) + c mathopu(θ) = cosθ","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"where we want a solution that is periodic on 02π).  This can be solved succinctly as follows:","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"julia> b = Fun(cos, Fourier());\n\njulia> c = 0.1;\n\njulia> u = (𝒟 + c*I) \\ b;\n\njulia> t = 0.6; # choose a point to verify the solution\n\njulia> u(t) ≈ (c*cos(t)+sin(t)) / (1+c^2) # exact solution\ntrue","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"Recall that 𝒟 is an alias to Derivative() == Derivative(UnsetSpace(),1).","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"As another example, consider the Fredholm integral equation","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"mathopu + mathope^x int_-1^1 cosx mathopu(x) mathopdx = cosmathope^x","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"We can solve this equation as follows:","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"DocTestFilters = r\"[0-9\\.]+\"","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"julia> Σ = DefiniteIntegral(Chebyshev());\n\njulia> x = Fun();\n\njulia> u = (I+exp(x)*Σ[cos(x)]) \\ cos(exp(x));\n\njulia> u(0.1)\n0.21864294855628819","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"DocTestFilters = nothing","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"note: Note\nWe used the syntax op[f::Fun], which is a shorthand for op * Multiplication(f).","category":"page"},{"location":"usage/equations/#Boundary-conditions","page":"Linear Equations","title":"Boundary conditions","text":"","category":"section"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"Incorporating boundary conditions into differential equations is important so that the equation is well-posed.  This is accomplished via combining operators and functionals (i.e., 1 × ∞ operators).  As a simple example, consider the first order initial value problem","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"begingathered\n    mathopu = t mathopu \n    mathopu(0) = 1\nendgathered","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"To pose this in ApproxFun, we want to find a u such that Evaluation(0)*u == 1 and (𝒟 - t)*u == 0.  This is accomplished via:","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"julia> t = Fun(0..1);\n\njulia> u = [Evaluation(0); 𝒟-t] \\ [1;0];\n\njulia> u(0) ≈ 1\ntrue\n\njulia> norm(u'-t*u) < eps()\ntrue","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"Behind the scenes, the Vector{Operator{T}} representing the functionals and operators are combined into a single InterlaceOperator.","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"A common usage is two-point boundary value problems. Consider the singularly perturbed boundary value problem:","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"begingathered\n    ϵ mathopu - x mathopu + mathopu = 0 \n    mathopu(-1) = 1 mathopu(1) = 2\nendgathered","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"This can be solved in ApproxFun via:","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"julia> ϵ = 1/70;\n\njulia> x = Fun();\n\njulia> u = [Evaluation(-1); Evaluation(1); ϵ*𝒟^2-x*𝒟+I] \\ [1,2,0];\n\njulia> u(0.1) ≈ 0.05 # compare with the analytical solution\ntrue","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"note: Note\nIn this case the space is inferred from the variable coefficient x.","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"This ODE can also be solved using the Dirichlet operator:","category":"page"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"julia> u = [Dirichlet(); ϵ*𝒟^2-x*𝒟+I] \\ [[1,2],0];\n\njulia> u(0.1) ≈ 0.05 # compare with the analytical solution\ntrue","category":"page"},{"location":"usage/equations/#QR-Factorization","page":"Linear Equations","title":"QR Factorization","text":"","category":"section"},{"location":"usage/equations/","page":"Linear Equations","title":"Linear Equations","text":"Behind the scenes, A\\b where A is an Operator is implemented via an adaptive QR factorization.  That is, it is equivalent to qr(A)\\b.  (There is a subtlety here in space inferring: A\\b can use both A and b to determine the domain space, while qr(A) only sees the operator A.)  Note that qr adaptively caches a partial QR Factorization as it is applied to different right-hand sides, so the same operator can be inverted much more efficiently in subsequent problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ApproxFun","category":"page"},{"location":"#ApproxFun.jl-Documentation","page":"Home","title":"ApproxFun.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ApproxFun is a package for approximating and manipulating functions, and for solving differential and integral equations.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic approach of computational mathematics that ApproxFun exploits is expansion in a basis","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathopf(x) approx sum_k=1^n c_k mathopψ_k(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some traditional examples of bases mathopψ_1(x) mathopψ_2(x)  are","category":"page"},{"location":"","page":"Home","title":"Home","text":"Taylor series: 1 x x^2 \nFourier series (for periodic functions on 0..2π): 1 sinx cosx sin2x \nChebyshev series (for non-periodic functions on -1..1): 1 x cos(2arccosx) cos(3arccosx) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In ApproxFun, functions are represented by a Fun with two components: space, which dictates the basis and coefficients which is a finite vector of coefficients.  Note that each Fun can have a different length vector of coefficients, allowing for approximation of many different functions to high accuracy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The approximation by a Fun can be determined by a variety of methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(1) Explicitly specifying the coefficients:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = Fun(Taylor(),[1,2,3])  # Represents 1 + 2x + 3x^2\nf(1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(2) Constructors take in a Function and adaptively determine the number of coefficients.  For example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fun(exp)","category":"page"},{"location":"","page":"Home","title":"Home","text":"determines that f can be approximated to roughly machine precision using 14 coefficients.  See Constructors for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(3) Manipulation of Funs give new Funs, where the number of coefficients is determined from the input.  The simplest example is addition, which for compatible bases is just padding the vectors to the same length and adding.","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = Fun(cos,Chebyshev()); ncoefficients(a)\nb = Fun(x->cos(10cos(x^2)),Chebyshev()); ncoefficients(b)\nncoefficients(a+b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, multiplication results in an approximation with more coefficients than either a or b, so that the result approximates the true a*b to roughly machine accuracy:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ApproxFun\na = Fun(cos,Chebyshev())\nb = Fun(x->cos(10cos(x^2)),Chebyshev())","category":"page"},{"location":"","page":"Home","title":"Home","text":"ncoefficients(a*b)\na(0.1)*b(0.1) - (a*b)(0.1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The example of multiplication highlights the importance of adaptivity: if with a fixed discretization size, operations like multiplication would lose accuracy when the true function is no longer resolved by the discretization.  More complicated examples are solving differential equations, where the coefficients of the solution can be determined adaptively, see Equations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ApproxFun supports a number of different spaces, as described in Spaces.  A key component of ApproxFun is support for interaction between different spaces.  This is crucial for efficient solution of differential equations, where linear operators are described as acting between different spaces, see Operators.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"usage/domains.md\",\n         \"usage/spaces.md\",\n         \"usage/constructors.md\",\n         \"usage/operators.md\",\n         \"usage/equations.md\",\n         \"faq.md\",\n         \"library.md\"]","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"EditURL = \"../../../examples/NonlinearBVP.jl\"","category":"page"},{"location":"generated/NonlinearBVP/#Nonlinear-Boundary-Value-Problem","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"","category":"section"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"There is preliminary support for nonlinear equations, via Newton iteration in function space. Here is a simple two-point boundary value problem:","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"We solve","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"Du = 0001u^primeprime + 6(1-x^2)u^prime + u^2 - 1 = 0","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"subject to the boundary conditions u(-1)=1 and u(1)=-05.","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"using ApproxFun\nusing LinearAlgebra","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"Define the vector that collates the differential equation and the boundary conditions","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"N(u, x = Fun()) = [u(-1.)-1., u(1.)+0.5, 0.001u'' + 6(1-x^2)u' + u^2 - 1];\nnothing #hide","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"Solve the equation using Newton iteration","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"function nbvpsolver()\n    x = Fun()\n    u0 = 0 * x # starting value\n\n    newton(N, u0)\nend\n\nu = nbvpsolver();\nnothing #hide","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"We plot the solution","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"import Plots\nPlots.plot(u; title = \"Solution\", xlabel=\"x\", ylabel=\"u(x)\", legend=false)","category":"page"},{"location":"generated/NonlinearBVP/#System-of-nonlinear-differential-equations","page":"Nonlinear Boundary Value Problem","title":"System of nonlinear differential equations","text":"","category":"section"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"One can also solve a system of nonlinear ODEs with potentially nonlinear boundary conditions:","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"using ApproxFun\nusing LinearAlgebra\n\nN(u1, u2) = [u1'(0) - 0.5*u1(0)*u2(0);\n                u2'(0) + 1;\n                u1(1) - 1;\n                u2(1) - 1;\n                u1'' + u1*u2;\n                u2'' - u1*u2]\n\nfunction nbvpsolver2()\n    x = Fun(0..1)\n    u10 = one(x)\n    u20 = one(x)\n    newton(N, [u10,u20])\nend\nu1,u2 = nbvpsolver2();\nnothing #hide","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"Plot the solutions","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"import Plots\nPlots.plot(u1, label=\"u1\", xlabel=\"x\")\nPlots.plot!(u2, label=\"u2\")","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"","category":"page"},{"location":"generated/NonlinearBVP/","page":"Nonlinear Boundary Value Problem","title":"Nonlinear Boundary Value Problem","text":"This page was generated using Literate.jl.","category":"page"}]
}
